# 第2章
## 目录
1. 基本内置类型
   * 算数类型
   * 类型转换
   * 字面值常量
2. 变量
   * 变量定义
   * 变量声明和定义的关系
   * 标识符
   * 名字的作用域
3. 复合类型
   * 引用
   * 指针
   * 理解复合类型的声明 
4. const限定符
   * const和引用
   * 指针和const
   * 顶层const
   * constexpr和常量表达式
5. 处理类型
   * 类型别名
   * auto类型说明符
   * decltyoe类型指示符
6. 自定义数据结构
   * 定义Sales_data类型
   * 使用Sales_data类
   * 编写自己的头文件
* 小结
* 术语表


----------------------------------

任何常用的编程语言都具备一组公共的语法特征, 不同语言仅在特征的细节上有所区别. 要想学习并掌握一种编程语言, 理解其语法特征的实现细节是第一步.
大多数 编程语言通过两种方式来进一步补充其基本特征: 一是赋予程序员自动定义数据类型的权利, 从而实现对语言的扩展; 二讲一些有用的功能封装成库函数提供给程序员.

----------------------------------

# 正文
## 1. 基本内置类型
* C++定义了一套包括`算术类型`和`空类型void`在内的基本数据类型。
* `算数类型`包括:
    1. 字符
    2. 整型数
    3. 布尔值
    4. 浮点数
* 空类型不对应具体的值

### 1.1 算术类型
* `算术类型分类`:
    1. 整型(intergral type，包括字符和布尔类型在内) 和 浮点型 
   
* `算术类型`如下
    ```cpp
    bool 
    char  wchar_t  char16_t  char32_t
    short  int long  long long
    float  double  long double
    ```

* `内置类型`的机器实现
    1. 可寻址的最小内存块成为`"字节(byte)"`.存储的基本单元成为`"字(word)"`,通常由几个字节组成, 大多数机器的字由4或8字节组成.
    2. 为了赋予内存中某个地址的明确含义,必须首先知道存储在该地址的数据的类型.类型决定了数据所占的比特数以及该如何解释这些比特的内容.

* `除去布尔型和扩展的字符型之外, 其他整型可以划分为带符号和无符号的两种`. 
    1. 带符号可以为正数 负数 0
    2. 无符号只能大于等于0

### 1.2 类型转换
* `转换`
    1. 对象的类型定义了对象能包含的数据和能参与的运算，其中一种`运算`被大多数类型支持，转换是一种运算
    2. 就是将对象从一种给定的类型`转换(convert)`为另一种相关类型。
   
* `转换的规则`：
    1. 当把一个非布尔类型的算术值赋给布尔类型时, 初始值为0则结果为false, 否则结果为true。
    2. 当把bool值赋给非bool类型时, 初始值为false则结果为0, 初始值为true则结果为1。
    3. 当把浮点数赋给整数类型时, 进行了近似处理, 结果值将仅保留浮点数中小数点之前的部分。
    4. 当赋给无符号类型一个超出它表示范围的值时,结果是初始值对无符号类型标识数值总数取模后的余数. 例如,8 bit的unsigned char可以标识0-255,如果超出这个范围,结果为值对256取模后的余数.因此把-1赋给8 bit的unsigned char所得结果是255。
    5. 当给带符号类型一个超出它标识范围的值时,结果是未定义的.此时,程序可能继续工作、可能崩溃，也可能生成垃圾数据。

* `含有无符号类型的表达式的转换`
    1. 当一个算术表达式中既有无符号数又有int值时， 那个int值就回转换成无符号数， 把int转换成无符号数的过程和把int 直接赋给无符号变量一样
    2. 如过无符号类型表达式减为负数,则将这个负数转为无符号型(转换方法见上)
    3. 如果表达式里既有带符号类型又有无符号类型,当带符号类型取值为负时会出现异常结果, 因为带符号数会自动转换为无符号数,带符号类型取值不为负不会则不会先自动转换?
    4. `2021.11.21` : 如果相减，最后结果为负，则要转换。

### 1.3 字面值常量
* `字面值常量`
    1. 形如42的值被称作字面值常量，这样的值一望而知。
    2. 每个字面值常量都对应一种数据类型，字面值常量的形式和值决定了它的数据类型

* `整形和浮点型字面值`
    1. 整型(十进制、八进制、十六进制)(20、024、0x14)
    2. 浮点型字面值(默认double)
   
* `字符和字符串字面值`
     1. 字符('a')
     2. 字符串字面值("hello",实际上是又常量字符构成的数组)
   
* `转义序列可以表示`
    1. 不可打印字符(如换行符  横向制表符)
    2. C++语言中有特殊含义的字符(单引号、双引号、问号、反斜线) 
   
* `指定字面值类型`：可通过前缀、后缀改变整型、浮点型和字符型字面值的默认类型

* `布尔字面值`为true false 和 `指针字面值`为nullptr

## 2. 变量
* 变量提供一个具名的、可供程序操作的存储空间。C++中的每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算。

### 2.1 变量定义
* `变量定义的基本形式`
    一条声明语句由一个 `基本数据类型`（类型说明符type specifier） 和紧随其后的一个`声明符`列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型。

* `对象`
      是具有某种数据类型的内存空间

*  `初始化` 
   当对象在创建时获得了一个特定的值，我们说这个对象被初始化了。`初始化的含义是创建变量时赋予一个其初始值`

* `初始化的方式`：
    * `说法1`:
        1. `默认初始化`:如果定义变量没有指定初值,则变量被默认初始化。全局就初始化为0，函数体内部的内置类型将`不被初始化`。
        2. `直接初始化`:不使用等号, 则执行的是直接初始化,()方式。
        3. `拷贝初始化`:如果使用一个等号初始化一个变量，实际上执行的是拷贝初始化。编译器会把等号右侧的初始值拷贝到新创建的对象中去。
        4. `值初始化`:值初始化仅限于容器类。
       
    * `说法2`:
        1. `默认初始化`:默认初始化是指定义变量时没有指定初值时进行的初始化操作
        2. `值初始化`:是指使用了初始化器(即使用了圆括号或花括号) 但没有提供初始值的情况
        3. `直接初始化`：直接初始化是指采用小括号的方式进行变量初始化（小括号里一定要有初始值，如果没提供初始值，那就是值初始化了！）。
              1. 直接初始化与拷贝初始化：简而言之复制初始化使用“＝”符号，而直接初始化将初始化式放在圆括号中。
              2. 对于内置类型变量（如int，double，bool等），直接初始化与拷贝初始化差别可以忽略不计。
              3. 对于类类型的变量（如string或其他自定义类型），直接初始化调用类的构造函数（调用参数类型最佳匹配的那个），拷贝初始化调用类的拷贝构造函数。 
        4. `拷贝初始化`：拷贝初始化是指采用等号（=）进行初始化的方式，编译器把等号右侧的初始值拷贝到新创建的对象中去。
        5. `列表初始化`：列表初始化是C++ 11 新引进的初始化方式，它采用一对花括号（即｛｝）进行初始化操作。能用直接初始化和拷贝初始化的地方都能用列表初始化，而且列表初始化能对容器进行方便的初始化，因此在新的C++标准中，推荐使用列表初始化的方式进行初始化。
        6. 使用new动态分配的默认初始化和值初始化
    
    * `primer中39页例子`
         ```cpp
         int units_sold = 0;   // 拷贝初始化
         int units_sold = {0};  //jsh:拷贝初始化
         int units_sold{0};   //  jsh：列表初始化
         int units_sold(0);  // jsh:直接初始化
         ```

* 在大多情况下`初始化方式可以相互等价的使用`，不过也并非一直如此
    1. 使用`拷贝初始化`时(即使用=)只能提供一个初始值
    2. 如果提供的是一个`类内初始值`，则只能使用拷贝初始化或使用花括号的形式初始化。
    3. 如果提供的是`初始元素值的列表`，则只能把初始值都放在花括号里进行列表初始化，而不能放圆括号里

*  `赋值`的含义是把对象当前值擦除.而以一个新值来替代。C++中出书


### 2.2 变量声明和定义的关系
* `分离式编译`
    * 该机制允许将程序分割为若干个文件，每个文件可被独立编译
    * 为了支持分离式编译，C++将声明和定义区分开来。
    * 如果要在多个文件中使用同一个变量,而其他用到该变量的文件必须对其进行声明,却绝对不能重复定义

* `声明`：使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明
  
* `定义`：负责创建与名字关联的`实体`。

* `生命与定义的异同`
    1. 变量的声明规定了变量的类型和名字，这一点上定义与之相同。
    2. 除此之外，定义还申请存储空间，也可能会为变量赋一个初始值，
    3. 声明可以多次， 定义只能一次
   
* `书中例子41页`
     1. `extern int i;` // 声明i
     2. `int j;` //声明并定义j
     3. `extern double pi = 3.1415` // 定义,给extern关键字标记的变量赋初值,则抵消extern的作用`在函数体内部,如果试图初始化一个有extern关键字编辑的变量, 将引发错误.`


### 2.3 标识符
* `C++标识符(identifier)` : 由字母、数字和下划线组成,其中必须以字母或下划线开头.

* `用户自定义标识符规则`
    * 不能为关键字
    * 不能连续出现两个下划线  __
    * 不能以下划线紧连大写字母开头 _A
    * 定义在函数体外的标识符不能以下划线开头  _

* `C++关键字`
    1. alignas     continue       friend     register            true
    2. alignof     decltype        goto      reinterpret_cast    try
    3. asm         default         if        return              typedef
    4. auto        delete          inline    short               typeid
    5. bool        do           int        signed              typename
    6. break         double         long        sizeof              union
    7. case         dynamic_cast         mutable        static              unsigned
    8. catch         else         namespace        static_assert          using
    9. char  enum  new  static_cast virtual
    10. char16_t  explicit  noexcept  struct  void
    11. char32_t  export  nullptr   switch   volatile
    12. class   extern   operator     template   wchar_t
    13. const   false    private    this    while
    14. constexpr   float   protected    thread_local
    15. const_cast   for   public   throw

* `C++操作符替代名`
    1. and  bitand   compl   not_eq   or_eq   xor_eq
    2. and_eq  bitor   not  or  xor 

### 2.4 名字的作用域
* `c++中的名字`：
    不管在程序的什么位置，使用到的每个名字都会指向一个特定的实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同位置，也可能指向的是不同实体。
  
* `名字作用域分为` 
    1. 全局作用域
    2. 块作用域（局部作用域）
   
* `作用域可以一直嵌套` : 套娃  `内层作用域`  `外层作用域`
  
* 取全局作用域下变量的一种方式 `::val`
    因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。

## 3. 复合类型
* `复合类型`:是指基于其他类型定义的类型，C++语言有几种复合类型，此章介绍引用和指针

* `声明语句`：一条声明语句由一个`基本数据类型`(base type) 和紧随其后得一个`声明符`列表组成。每个声明符命名了一个变量并指定该变量为与基本数据类型有关的某种类型

### 3.1 引用
* `右值引用`:C++11中新增了一种引用`右值引用`(rvalue reference) p471(详细)。这种引用主要用于 `内置类`。通常说的术语引用(reference) 指的是 左值引用(lvalue reference)。
  
* `引用`:引用为对象起了另外一个名字，引用类型引用(refers)另外一种类型。
  
* `引用的规则`：
    1. 引用必须初始化且无法令引用重新绑定
    2. 声明符写成 &d
    3. 引用本身不是一个对象，是个别名，所以没有引用的引用`(引用并非对象，相反的，它只是为一个已经存在得对象所起得另外一个名字)`
    4. 引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起
    5. `除两种例外情况外（p55(4.1 const与引用)，p534）`，`引用的类型要和与之绑定的对象类型相匹配`
          1. `第一种：对常量的引用`： 
             1. 在初始化常量引用时允许用任意表达式作为初始值，只要该`表达式`的结果能转换成`引用的类型`即可(`编译器会创建一个const的临时对象，让其绑定`)；
             2. 即常量引用仅对`引用可参与的操作做出了限定`，`对于引用的对象本身是不是一个常量未作限定`。 -->对象如果非常量，则允许通过其他途径更改

### 3.2 指针
* `指针`:是指向(point to)另外一种类型的复合类型

* `引用和指针的区别`
    1. 指针本身就是个对象，允许对指针进行赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。
    2. 指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。
    3. 指针和引用都能提供对其他对象的间接访问,然而在具体实现细节上二者有很大的不同,其中最重要的一点就是引用本身并非一个对象。
   
* `指针的规则`:
    1. 将声明符写成*d形式     用&获取对象的地址
    2. 用指针访问对象: `*ptr` 解引用符
    3. 指针不能指向引用，因为引用不是对象，无地址
    4. 除`两种例外情况（p56(2.4.2指针和const)，p534）`，`其他所有指针类型都要和它指向的对象严格匹配`。
          1. `第一种：指向常量的指针`：和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变
  
* `指针的值`应属于以下4中状态之一
    1. 指向一个对象
    2. 指向紧邻对象所占空间的下一个位置(有效,但访问指向对象不被允许)
    3. 空指针(有效,但访问指向对象不被允许)
    4. 无效指针，上述情况之外的其他值(野指针)

* `空指针`
    1. c++11可以用nullptr字面值常量初始化指针(C++11新标准)
    2. 也可以用字面值0生成空指针
    3. NULL是预处理变量`在cstdlib中定义，它的值就是0`  `预处理器:编译过程之前的一段程序`

* `void*指针`
    1. 是一种特殊的指针，可以存放任意对象的地址。
    2. 但是不能同过这个指针操作这个对象，因为无法确定是什么类型，所以也无法确定是什么操作。
    3. 它可看作仅仅是一个内存空间。
    4. P726(介绍void*)  P144(获取指针所存地址的方法)详细介绍void*(后面总结在一起)


### 3.3 理解复合类型的声明
* `前言`：变量的定义包括一个基本数据类型和一组声明符`(声明符中修饰符的个数没有限制，当有多个修饰符连在一起时，按照其逻辑关系详加解释即可。)`

* `理解的方法论`：想要理解一个变量类型是什么，最简直的办法就是从右往左阅读它的定义，离变量名最近的符号对变量类型有最直接的影响。

* `指向指针的指针`
     通过 * 的个数可以区分指针的界别。 `**`表示指向指针的指针   `***`表示指向指针的指针的指针\

* `指向指针的引用`
    1. 引用本身不是一个对象， 因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用
    2. `形式为` `int *p;  int *&r = p;` 


## 4. const限定符
* `关键字const`
    * 希望定义一种值不能被改变的变量，可以用const对变量类型加以限定

* `const规则`
    1. 任何对const变量赋值的行为都将引发错误
    2. const对象一旦被创建后其值就不能再再变，所以const对象必须初始化 
    3. `const变量和非const类型仅仅在执行改变值得时候才会发挥作用`，其他类型操作和非const类型一致
    4. 默认状态下，const对象仅在文件内有效(为了避免对同一变量的重复定义)

* `extern const int bufszie`
    * 需求: 有时候一种const变量,它得初始值不是常量表达式, 但必须在文件间共享.这种情况下,我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类const对象像其他(非常量)对象一样工作。`一个文件中定义const，而在其他多个文件中声明并使用它`(默认状态下，const对象仅在文件内有效)
    * `解决办法`：对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了
    * `extern const int bufSize = fcn(); // file_1.cc`
    * `extern cosnt int bufSize; // 与file_1.cc中定义的bufSize是同一个`

### 4.1 const和引用
* `对常量的引用` 
    1. 可把引用绑在const对象上，就像绑定到其他对象上一样
    2. 与普通引用不同的是，对常量的引用不能被用作修改它绑定的对象
    3. 平时说的"常量引用"就是"对常量的引用"
    4. 常量引用仅对`引用可参与的操作做出了限定`
    
* `引用类型必须和其所引用的对象的类型一致，第一种例外情况`
     在初始化常量引用时允许用任意表达式作为初始值，只要该`表达式`的结果能转换成`引用的类型`即可(`编译器会创建一个const的临时对象，让其绑定`)

* `对const的引用 可能引用 一个并非const的对象`
     * 即常量引用仅对`引用可参与的操作做出了限定`，`对于引用的对象本身是不是一个常量未作限定`。 -->对象如果非常量，则允许通过其他途径更改

### 4.2 指针和const
* `指向常量的指针(pointer to const)`
    1.  指针类型都要和它指向的对象严格匹配`第一种例外情况`
    2.  要想存放`常量对象的地址`，只能用`指向常量的指针`
    3.  和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅`要求不能通过该指针改变对象的值`，而`没有规定那个对象的值不能通过其他途径改变`(`编译器会创建一个const的临时对象，让其绑定`？？？)
    4.  `可以看作`：所谓指向常量的指针或引用，不过是指针或引用自己以为指向了向量，所以自觉地不改变所指对象的值

* `常量指针(const pointer)`
    1. 指针是对象而引用不是，所以允许把指针本身定为常量
    2. `必须初始化`，一旦初始化完成，则值不允许改变 
    3. 把 `* const` `*放在const之前`用以说明指针是一个常量，即不变的是指针本身而非指向的那个值

### 4.3 顶层const
* `const`才说底层const 顶层const。底层顶层是针对const而言。

* `顶层const (top-level const)`
    1. `例如指针`：用名称顶层const表明指针本身是常量
    2. `一般来说`：顶层const可以表示任意的对象(任意数据类型：算术类型、类、指针(不包括引用，因为引用不是对象)等)是常量
    3. `自己的理解`：顶层const：对象的本身值不能改变，底层const是不能改变指向了。

* `底层const (low-level const)`
    1. `例如指针`：用名词底层const表明指针所指的对象是常量 
    2. `一般来说`：底层const则与`指针和引用`等`复合类型`的基本类型部分有关。

* `执行对象的拷贝操作时，两者的区别：`
    1. `顶层const不受影响`(因为顶层const拷贝是 对常量进行拷贝 没啥影响) 
    2. `拷贝操作并不会改变被拷贝对象的值`
    3. `底层const限制不容忽视。`当执行对象拷贝操作时候，拷入拷出的对象`必须`具有相同的底层const资格，`或者`两个对象的数据类型必须能够转换。一般来说，非常量可以转换为常量，反之不行。
    4. `顶层const`可以`右(顶层const)对左`赋值操作。但`底层const`有限制，`右(底层const)对左` 拷入拷出的对象也必须具有相同的底层const(引用和指向相同的类型`or`可以转换)。

* `书中代码P58页`
    ```cpp
    int i = 0;
    int *const p1 = &i;  // 不能改变p1的值，顶层const
    const int ci = 42;  // 不能修改ci的值， 顶层const
    const int *p2 = &ci;  // 能修改p2的值，底层const
    const int *const p3 = p2; // 左边是底层const  右边是顶层const
    const int &r = ci; // 指向的值不能改变，底层const
    
    i = ci; // 正确：拷贝ci的值，ci是顶层const，对此操作无影响
    p2 = p3; // 正确：指向类型相同，虽然p3不可以改变指向，但p2可以改变指向，p3顶层const部分不影响这个操作。


    int *p = p3; // 错误：p3底层const是指向const int， 而int *p不是，所以不能。
    p2 = p3; // 正确：p2和p3指向的东西都一样，都是底层const,p2指向可以修改
    p2 = &i; // 正确，int*能转换成const int*，指向常量的指针没有规定指向的对象必须是常量
    int &r = ci; // 错误，ci是底层const，而r是普通的引用，ci是对常量的引用
    const int &r2 = i;  // 正确，对常量的引用对引用的对象是不是常量未作限定
    ``` 


### 4.4 constexpr和常量表达式
* `常量表达式`
    1. `值不会改变`并且在`编译过程就能得到计算结果的表达式`
    2. 字面值属于常量表达式，用常量表达式初始化得const对象也是常量表达式
    ```cpp
    const int max_files = 20; // 是
    const int limit = max_files + 1; // 是
    int staff_size = 27;  //不是
    const int sz = get_size(); // 不是，get_size运行时才能获得到，所以不是常量表达式
    ```

* `constexpr变量`
    1. `C++11新标准`，允许将变量声明为constexpr类型以便由编译器去来验证变量的值是否是一个常量表达式。
    2. 声明为constexpr的变量一定是一个常量，而且`必须用常量表达式初始化化`。        
    ```cpp
    constexpr int mf = 20;  // 是
    constexpr int limit = mf + 1; // 是
    constexpr int sz = size();   // 只有当size是一个constexpr函数时才是正确声明
    ```

* `constexpr函数`
    1. 不能用普通函数作为constexpr变量的初始值，但可以用`constexpr函数去初始化constexpr变量`。
    2. `C++11新标准`允许定义一种特殊的constexpr函数。这种函数应该足够简单以使得编译时就可以计算其结果。

* `字面值类型`
    1. 常量表达式的值需要在编译时就能得到计算，因此对声明constexpr时用到的类型必须有所限制。`把它们称为字面值类型`
    2. `算术类型`、`引用`和`指针`都属于字面值类型。自定义的类Sales_item、IO库、string类型不属于字面值类型。其他的字面值类型在`(7.5.6节 P267页   19.3节(736页))` 
    3. 指针和引用都能定义成constexpr，但他们`初始值受严格限制`。一个`constexpr指针的初始值必须是nullptr或者0`，或者是存储与`某个固定地址中的对象`。

* `变量地址` 
    1. `函数体内定义的变量`一般来说并非存放在固定地址中。因此constexpr指针不能指向这样的变量。 
    2. `所有函数体外定义的变量`地址固定不变，能用来初始化constexpr指针。
    3. `（6.1.1节 P185）`介绍一种函数定义一类有效范围超出函数本身的变量。这类变量和定义在函数体之外的变量一样也有固定地址。constexpr引用也可以绑定到这种变量，constexpr指针能指向这样的变量。`(static??)`

* `指针和constexpr`
    1. 如果constexpr声明中如果定义了一个指针，`限定符constexpr仅对指针有效，修饰指针的`，与指针所指的对象无关。
    2.  与其他常量指针类型，constexpr指针既可以指向常量也可以指向一个非常量。
    ```cpp
    // i的类型是整型常量
    // i和j必须定义在函数体之外,不然下述constexpr指针无法声明
    int j = 0;
    constexpr int i = 42; 
    
    constexpr const int *p = &i; // p是指向整型常量的常量指针
    // constexpr int *p1 = &i; // 错误,p1为指向常量的常量指针不能指向整型常量
    constexpr int *p1 = &j; // p1常量指针，指向整数j
    ```

* `疑惑待解？`字面值类型是一种变量类型的一种分类方式吗

## 5. 处理类型
* 随着程序越来越复炸，程序中用到的类型越来越复杂，体现在：
    1. 一些类型难于“拼写” ，它们的名字既难记又容易写错，还无法明确体现其真实目的和含义
    2. 有时候根本搞不清到底需要的类型是什么，不得不回过头去从程序的上下文中寻求帮助

### 5.1 类型别名
* `类型别名(type alias)`
    * 是一个名字，是某种类型的同义词，使用类型别名有很多好处，让复杂的类型名字变得简单明了。
    * 有两种方法可以定义类型别名
        1. `关键字typedef`:关键字typedef可作为声明语句中的基本数据类型的一部分出现。含有typedef的声明语句定义的不再是变量而是类型别名。这里的声明与距离的声明符也可以包含类型修饰，从而也能从基本数据类型构造出复合类型来
        ```cpp
        typedef double wages;  // wages是double的同义词
        typedef wages base, *p; // base是double同义词，p是double *同义词
        ```
        2. `别名声明alias declaration`作用是把等号左侧的名字规定成等号右侧类型的别名
        ```cpp
        using SI = Sales_item;
        ```

* `指针、常量和类型别名`
    如果某个类型别名指代的复合类型或常量，此时要注意 
    ```cpp
    /*const修饰的是pstring，而pstring是指针，所以 下面是常量指针*/
    typedef char *pstring;
    const pstring cstr = 0; // cstr是指向char的常量指针，基本数据类型是const pstring
    const pstring *ps;  // ps是一个指针，它的对象是指向char的常量指针，基本数据类型是const pstring
    ```

### 5.2 auto类型说明符
* `auto类型说明符C++11`
    1.  能让编译器去分析表达式所属的类型
    2.  `auto定义的变量必须有初始值`，auto让编译器通过`初始值`来推算变量的类型
    3.  auto语句能在一条语句中声明多个变量。`因为一条声明语句中只能由一个基本数据类型`，所有所有变量的初始剧本数据类型必须一致 `auto sz = 0, pi = 3.14; // 错误`

* `复合类型、常量和auto`
    1. `编译器推断出的auto类型有时候和初始值的类型不完全一样`
    2. 使用引用是使用引用的对象，当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器是以引用对象的类型作为auto的类型
        ```cpp
        int i = 0, &r = i;
        auto a = r;   // a是整型
        ```
    3. auto一般会忽略顶层const，不忽略底层const。如果希望推断出的auto类型是顶层const，需明确指出
        ```cpp
        const int ci = i, &cr = ci;
        auto b = ci; // b是整数(ci的顶层const特性被忽略掉了)
        auto c = cr; // c是一个整数 (cr是c的别名)
        auto d = &i;  // d是一个整型指针(整数的地址就是指向整数的指针)
        auto e = &ci;  // e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
        const auto &f = ci; // f 是 const int
        ```
    4. 可以将引用的类型设为auto(现在初始化规则就变成(正常的了)原来的规则了)。设置一个类型为auto的引用是，初始值中的顶层常量属性任然保留。
        ```cpp
        auto &g = ci; // g是一个整型常量引用(就是const int &g)，绑定到ci
        auto &h = 42; // 错误：不能为非常量引用绑定到字面值
        const auto &j = 42; // 正确，可以将常量引用绑定字面值
        ```
    5. 要在一条语句中定义多个变量，切记，符号&和*只从属于某个声明符，而非基本类型数据类型的一部分，因此初始值必须是同一种类型
        ```cpp
        auto k = ci, &l = i;     // 对
        auto &m = ci, *p = &ci;  // 对
        auto &n = i, *p2 = &ci;  // 错误，i是int ，ci是const int
        ```

### 5.3 decltyoe类型指示符
* `decltype类型说明符C++11`
    1. 希望从表达式的类型推断出要定义的变量的类型，但是不想用该表达式的值初始化变量。
    2. 作用是`选择并返回操作数的数据类型`。
    3. 编译器分析表达式并得到它的类型，却`不实际计算表达式的值`。`decltype(f()) sum = x;`意思就是编译器并不实际调用函数f，而是使用当调用发生时f的返回值类型作为sum的类型。

* `decltype和引用`
    1.  (4.1.1节 P120页，有些表达式将向decltype返回一个引用类型)。一般当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值
    2.  如果表达式是`解引用操作`，则decltype将得到`引用类型`。`因为解引用指针可以得到指针所指的对象，而且还能给这个对象赋值`

* `decltype和auto的区别`
    1. decltype处理顶层const和引用的方式与auto有些许不同。如果decltype使用的表达式是一个变量，则declttpe返回该变量的类型(包括顶层const和引用在内) 
    2. decltype和auto的另一处重要区别是：decltype的结果类型与表达式形式密切相关。`一种特殊情况`：如果变量名加上了一对括号(`decltype((i)) d`)，则得到的类型与不加括号是会有不同。`如果加了括号，编译器会把它当作一个表达式。``变量是一种可以作为赋值语句左值的特殊表达式`，所以这样decltype就会得到引用类型。(见代码)

* `Code`
    ```cpp
    // 2.5.3 decltype类型指示符
    const int ci = 0, &cj = ci;
    decltype(ci) x = 0;
    decltype(cj) y = x;
    // decltype(cj) z; // 错误，z是引用，必须初始化
    
    decltype(f()) sum = x;
    
    int i = 42, *p = &i, &r = i;
    decltype(r + 0) b; // 正确，加法的结果是int，因此b是一个未初始化的int
    // decltype(*p) c; // 错误：c是int &，必须初始化
    
    decltype((i)) d;  // 错误：d是int&，必须初始化 
    decltype(i) e;    // 正确：e是一个(未初始化的)int
    
    /*
    *   decltype((variable))的结果永远是引用，而decltype(variable)结果只有当variable本身
    *   就是一个引用时才是引用
    */
    ```

## 6. 自定义数据结构
* 从最基本的层面理解，数据结构是把一组相关的数据元素组织起来然后使用他们的策略和方法。
* C++允许用户以类的形式自定义数据类型，库类型string、istream、ostream等都是以类的形式定义的

### 6.1 定义Sales_data类型
* `定义Sales_data类型`
    1. 类以`关键字struct`开始，紧跟`类名`和`类体`(类体部分可以为空)。类体由花括号保卫形成了一个新的作用域。类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。
    2. 类体右侧表示节俗的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对类型对象的定义，所以`分号必不可少` 

* `类数据成员`
    1. * 数据成员定义了类的对象的具体内容，每个对象都有一份自己的数据成员拷贝。互不影响。
    2.  `C++11新标准`： 可以为数据成员提供一个类内初始值。创建对象时，`没有初始值的成员`将被默认初始化(全局比如int初始化为0，局部初始化不初始化)
    3. 类内初始值`不能用圆括号`，可以用`花括号`或者`等号`

* `Code`
    ```cpp
    struct A {} accum, trans, *salesptr;
    struct B {};
    B accum, trans, *salesptr; // 等价于上述A类定义，不建议A类定义的方式。
    struct Sales_data 
    {
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    };
    ```

### 6.2 使用Sales_data类
* `Code`
    ```cpp
    #include <iostream>
    #include <string>
    #include "Sales_data.h"
    int main() {
        // 添加两个Sales_data对象
        Sales_data data1, data2;
        // Sales_data对象读入数据
        double price = 0;
        std::cin >> data1.bookNo >> data1.units_sold >> price;
        data1.revenue = price * data1.units_sold;
        std::cin >> data2.bookNo >> data2.units_sold >> price;
        data2.revenue = price * data2.units_sold;
        // 检查data1和data2的ISBN是否相同的代码
        // 如果相同，求data1和data2的总和
        // 输入两个Sales_data对象的和
        if (data1.bookNo == data2.bookNo)
        {
            unsigned totalCnt = data1.units_sold + data2.units_sold;
            double totalRevenue = data1.revenue + data2.revenue;
            std::cout << data1.bookNo << " " << totalCnt 
                    << " " << totalRevenue << " ";
            if (totalCnt != 0)
                std::cout << totalRevenue / totalCnt << std::endl;
            else
                std::cout << "(no sales)" << std::endl;
        } else {
            std::cerr << "Data must refer to the same ISBN" << std::endl;
            return -1;
        }
        return 0;
    }
    ```

### 6.3 编写自己的头文件
* `类的定义`
    1. `19.7节(P754页)讲在函数体内定义类，但这样的类受到了一些限制`
    2. `类一般不定义在函数体内`。当在函数体外部定义类时，在各个源文件中可能只有一处该类的定义。如果要在不同文件中使用同一个类，类的定义就必须保持一致。`所以类通常被定义在头文件中`，且类所在头文件的名字应与类的名字一样。

* `头文件`
    1. 头文件通常是包含那些只能被定义一次的实体，如类、const和constexpr变量
    2. 头经常用到其他头文件的功能，容易重复包含，需要做防卫式声明。 

* `预处理器`
    1. 确保头文件多次包含仍能安全工作的常用技术是预处理器
    2. `预处理器`是编译之前的一段程序。比如看到`#include标记`就回用指定头文件的内容代替#include
    3. `头文件保护符header guard`依赖于`预处理变量(两种状态：已定义和未定义)`
       1. `#define`指令把一个名字设定以为预处理变量 
       2. `#ifdef`指令当且仅当变量已定义时为真
       3. `#ifndef`指令当且仅当变量未定义时为真，一旦检查结果为真，则执行后续操作直至遇到`#endif`指令为止
    4. 整个程序中`预处理变量`包括头文件保护符必须唯一，通常的做法是`基于头文件中的类的名字来构建保护符的名字，以确保其唯一性`。为了避免与程序中的其他实体发生名字冲突，`一般把预处理变量的名字全部大写`。

* `Code`
    ```cpp
    #ifndef SALES_DATA_H
    #define SALES_DATA_H
    #include <string>
    struct Sales_data 
    {
        std::string bookNo;
        unsigned units_sold = 0;
        double revenue = 0.0;
    };
    #endif
    ```




## 小结
## 术语表
