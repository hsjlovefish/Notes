# 第7章
# 目录
1. 定义抽象数据类型
   * 设计Sales_data类
   * 定义改进的Sales_data类
   * 定义类相关的非成员函数
   * 拷贝、赋值和析构
2. 访问控制与封装
   * 友元
3. 类的其他特性
   * 类成员再探
   * 返回*this的成员函数
   * 类类型
   * 友元再探
4. 类的作用域
   * 名字查找与类的作用域
5. 构造函数再探
   * 构造函数初始值列表
   * 委托构造函数
   * 隐式的类类型转换
   * 聚合类
   * 字面值常量类
6. 类的静态成员
* 小结
* 术语表

> 类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现的分离的设计技术。
> 类的接口包括用户能执行的操作，类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
> 封装实现了类的接口和实现的分离。

## 1. 定义抽象数据类型
### 1.1 设计Sale_data类
作为一个设计良好的类，既要有直观且易于使用的接口，也必须具备高效的实现过程

* `使用改进的Sales_data类`
    1. 占位，这里没有重点内容

### 1.2 定义改进的Sales_data类
* `定义成员函数`

* `引入this`
    1. 如果调用`totaol.isbn()`，则编译器负责把total的地址传递给isbn的隐式形参this，可以等价地认为编译器将该调用冲写成了如下的形式:`Sales_data::isbm(&total)`, 调用Sales_data的isbm成员时传入了total的地址。
    2. 任何对类成员的直接访问都被看作this的隐式引用。this是一个常量指针

* `引入const成员函数`
    ```cpp
    std::string isbn() const { return bookNo; }  // 这种成员函数被称作 常量成员函数 const member function
    // cosnt 关键字，这里const的作用是修改隐式this指针的类型
    // 默认情况下，this的类型指向 类类型非常量版本 的常量指针。
    // 如果是常量对象，那么普通的this就不能指向了
    // +了const this 就生命成 const Sales_data *const

    // 等价于 伪代码
    std::string Sales_data::isbn(const Sales_data *const this) { return this->isbn; }
    ```

* `类作用域和成员函数`
    1. 类本身就是一个作用域
    2. 尽管成员的声明在方法之后，但方法能用成员的原因：编译器分两步处理类，首先编译成员的声明，然后才轮到成员函数体（如果有）

* `在类的外部定义成员函数`
    ```cpp
    Sales_data::avg_price使用了作用域运算符来说明:
    我们定义了一个名为xxx的函数，并且该函数被声明在类Sales_data的作用域内。
    一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的
    ```

* `定义一个返回this对象的函数`
    ```cpp
    Sales_data& Sales_data::combine(const Sales_data &rhs) {
        units_sold += rhs.units_sold;
        revenue += rhs.revenue;
        return *this;
    }
    // 注意返回类型和返回语句
    // 当定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符
    // "内置的赋值运算符把它的左侧运算对象当成左值返回"
    // 因为上面的函数为了保持一致，combine函数返回引用类型，返回来的类型为Sales_data&
    ```

### 1.3 定义类相关的非成员函数
* `定义read和print函数`
    1. 注意IO类属于不能被拷贝的类型，只能通过引用来传递它们
    2. 在书P234中read和print函数中，IO不是const&，是因为读取和写入操作会改变流的内容

* `定义add函数`
    1. 占位

### 1.4 构造函数
* `构造函数`
    1. 每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做`构造函数(constructor)`
    2. 无论何时只要类的对象被创建，就回执行构造函数
    3. `notion`: 构造函数不能被声明成const，当创建类的一个const对象时，知道构造函数完成初始化过程，对象才能真正取得其"常量"属性。因此，构造函数在const对象的构造过程中可以向其写值

* `合成的默认构造函数`
    1. 默认构造函数: 类通过一个特殊的构造函数来控制默认初始化过程。默认构造函数无须任何实参
    2. 如果没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数(合成的默认构造函数(synthesized default constructor));`如果存在类内的初始值，用它初始化成员；否则，默认初始化成员`
    3. `编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。` 考虑是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制

* `某些类不能依赖于合成的默认构造函数`
    1. 如果一个类的内置类型或复合类型(如数组和指针)的对象被默认初始化，他的值是未定义的。这时候可以定义一个默认构造函数，否则可能发生未定义的行为
    2. 有的时候编译器不能为某些类合成默认构造函数。如 类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，必须自定义默认构造，否则该类没有可用的默认构造。13.1.6节449页中有其他情况也会导致无法生成正确的默认构造

* `定义Sales_data的构造函数`
    1. 略，里面是没有太多意义的内容

* `=default的含义`
    1. C++11中，如果需要默认的行为，可以通过=default来要求编译器生成构造函数。
    2. 如果=default在类的内部，则默认构造函数是内联的，如果他在类的外部，则该成员默认情况下不是内联的

* `构造函数初始值列表(constructor initialize list)`
    1. 知道，所以就不记录了

* `在类的外部定义构造函数`
    ```cpp
    Sales_data::Sales_data(std::istream &is) {
        read(is, *this);
    }
    // 这个构造函数没有构造函数初始值列表，因此它的构造函数初始值列表是空的。
    // 虽然是空的，但优于执行了构造函数提，所以对象的成员仍然能被初始化
    ```

### 1.5 拷贝、赋值和析构
* 除了定义类的对象如何被初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。如果不主动定义这些操作，编译器将替我们合成它们。

* `某些类不能依赖于合成的版本`
    1.就是深拷贝的时候

## 2.访问控制与封装
* `访问说明符(access specifiers)`
    1. public\private\protect
    2. 出线次数不限定，每个访问说明符制订了接下来的成员的访问等级，其有效范围直到出线下一个访问说明符或者到达类的结尾处尾置


* `使用class或struct关键字`
    1. struct是public、class是private
    2. 出于统一编程风格的考虑，希望定义的类的所有成员是public时，使用struct。如果希望陈院士private，使用class

### 2.1 友元
* `友元的声明`
    1. 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的`友元(friend)`
    2. 定义方法: friend关键字`friend Sales_data add(const Sales_data&, const Sales_data&)`
    3. 友元声明只能出现在类定义的内部。一般来说，最好在类定义开始或结束前的位置集中声明友元
    4. `友元的声明仅仅指定了访问的权限`，而非一个`通常意义上的声明`。如果希望类的用户能够调用某个友元函数，那么必须在友元声明之外再专门对函数进行一次声明
    5. 为了是友元对类的用户可见，通常把友元的声明与类本身放置在同一个头文件中

## 3.类的其他特性
### 3.1 类成员再探
* `定义一个类型成员`
    ```cpp
    class Screen {
    public:
        typedef std:string::size_type pos; // 这就是定义一个类型成员
        // 一般需要放在类开始的地方。因为先定义后使用
    }
    ```

* `Screen类的成员函数`
    * 略

* `令成员作为内联函数`
    * 类内部的成员函数是自动inline的
    * 书中推荐在类外部定义的地方说明inline，这样可以使类更容易理解

* `重载成员函数`
    * 成员函数也可以被重载

* `可变数据成员`
    1. 考虑：希望能修改类的某个数据成员，即使实在一个const成员函数内。这种情况考虑加入mutable关键字
    2. 一个`可变数据成员`永远不会是const，即使它是const对象的成员

* `类数据成员的初始值`
    1. 当希望某个类开始时总是拥有一个默认初始化的值。在C++11中，最好的方式是把这个默认值声明成一个类内初始值。
    2. 类内初始值必须使用`=的初始化形式` ， 或者花括号括起来的直接初始化形式

### 3.2 返回*this的成员函数
```cpp
inline Screen &Screen::set(pos r, pos col, char ch);
```

* `从const成员函数返回*this`
    1. 如果一个`const成员函数`以引用的形式返回*this，那么它的返回类型将是常量引用

* `基于const的重载`
    ```cpp
    class Screen {
    public:
        Screen &display(std::ostream &os) {
            do_display(os);
            return *this;
        }

        const Screen &display(std::ostream &os) const {
            do_display(os);
            return *this;
        }

        // 对于display函数，这样写比较好。
        // const对象和非const对象都能调用到合适的函数

        /* 为什么要单独写一个do_display?
        *
        *  1. 避免多出使用相同代码
        *  2. 如果类规模发展，display函数可能变得更加复杂，因此把相同的操作写在一处比较合适
        *  3. 可能需要在开发过程中给 do_display 函数添加某些调试信息，而这些信息将在代码的最终产品版本中去掉。显然只添加删除do_display比较容易
        *  4. (了解一下) 这种函数不会增加任何开销，因为在类的内部定义了do_display，所以它隐式地被声明成内联函数
        */
    }
    ```

### 3.3 类类型
* 每个类定义了唯一的类型，即使它们的成员完全一样，这两个类也是两个不同的类型

* `类的声明`
    1. 就像函数的声明和定义分离开一样，也可以仅仅声明类而暂时不定义它
    ```cpp
    class Screen;  // 有时被称作前向声明, 在它声明之后定义之前是一个`不完全类型`

    /*
    *   不完全类类型只能在非常有限的情景下使用：
    *   可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为掺和或者返回类型的函数
    */
    ```
    2. 对一个类来说，只有类被定义，编译器才能引用或者指针访问其成员
    3. 一个类名字出现之后，它就被认为是声明过了，因此类允许包含指向它自身类型的引用或指针

### 3.4 友元再探
* 类除了把普通的非成员函数定义成友元，还可以把其他类定义成友元，也可以把其他类的成员函数定义成友元

* `类之间的友元关系`
    1. 类里面放友元
    ```cpp
    class Screen {
        friend class Window_mgr;
    }
    ```

* `令成员函数作为友元`
    ```cpp
    class Screen {
        friend void Window_mgr::clear(ScrrenIndex);
    }
    ```

* `函数重载和友元`
    1. 如果一个类想把一组重载函数声明成它的友元，需要每一个都做声明(废话)

* `友元声明和作用域`
    1. 友元声明的作用是影响访问权限，本身并非普通意义上的声明
    2。 略

## 4.类的作用域
* 每个类都会定义自己的作用域。在类的作用域之外，普通的数据和函数成员只能由`对象、引用或者指针`使用成员访问运算符来访问

* `作用域和定义在类外部的成员`
    1. `一个类就是一个作用域`, 所以在类的外部定义成员函数时必须同时提供类名和函数名
    ```cpp
    class Window_mgr {
    public:
        // ScreenIndex是Window_mgr类定义的类型
        ScreenIndex addScreen(const Screen&);
    }

    // 因为这函数返回类型出现在类名之前，所以事实上它是位于Window_mgr类的作用域之外的。因此我们需要加上作用域
    Window_mgr::ScreenIndex
    Window_mgr::addScreen(const Screen &s) {
        // ...
    }
    ```

### 4.1 名字查找与类的作用域
* `用于类成员声明的名字查找`
    1. 编译器处理完类中的全部声明后才会处理成员函数的定义

* `类型名要特殊处理`

* `成员定义中的普通块作用域的名字查找`
    1. 首先，在成员函数内查找该名字的声明
    2. 如果成员函数内没有找到，则在类内继续查找
    3. 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找

* `类作用域之后,在外围的作用域中查找`
    1. 略

* `在文件中的名字出现的处对其进行解析`
    1. 略，不重要

## 5.构造函数再探
* 如果没有在构造函数的初始值列表中显式的初始化成员，则该成员将在构造函数体之前执行默认初始化

### 5.1 构造函数初始值列表
* `构造函数的初始值有时必不可少`
    1. 如果成员是`const或者引用`的话，必须初始化
    2. 如果`成员是类类型但该类没有定义默认构造函数时`，也必须初始化

* `成员初始化的顺序`
    1. 成员初始化顺序与它们在类定义中出现的顺序一致，初始值列表中初始化值前后位置关系不会影响实际初始化顺序
    2. `如果一个成员使用另一个成员来初始化的，那两个成员的初始化顺序就很关键了`
    3. `尽量保持顺序一致，尽量避免使用某些成员初始化其他成员`

* `默认实参和构造函数`
    1. 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数

### 5.2 委托构造函数
* `委托构造函数C++11`
    1. 一个委托构造函数使用它所述类的其他构造函数执行它自己的初始化构成，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数
    ```cpp
    class Sales_data {
    public:
        // 非委托构造函数
        Sales_data(std::string s, unsigned cnt, double price) :
            bookNo(s), units_sold(cnt), revenue(cnt * price) {}
        // 委托构造函数
        Sales_data() : Sales_data("", 0, 0) {}
        Sales_data(std::string s) : Sales_data(s, 0, 0) {}
        Sales_data(std::istream &is) : Sales_data() {
            read(is, *this);
        }
    }
    ```

### 5.3 默认构造函数的作用
* `当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在一下情况下发生:`
    1. 当我们在块作用域不使用任何初始值定义一个非静态变量或者数组时
    2. 当一个类本身含有类类型的成员且使用合成的默认构造函数时
    3. 当类类型的成员没有构造函数初始值列表中显式的初始化时

* `值初始化在以下情况下发生:`
    1. 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时
    2. 当我么不使用初始值定义一个局部静态变量时
    3. 当我们通过书写如`T()`的表达式显式地请求值初始化时

* `使用默认构造函数`
    1.  如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对
    ```cpp
    Sales_data obj(); // 注意！ 这是声明了一个函数，而非对象
    Sales_data obj2;  //  obj2是一个对象
    ```

### 5.4 隐式的类类型转换
* `转换构造函数`
    1. 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换极致，有时把这种构造函数称作`转换构造函数`(将在14.9节 514页介绍如何定义一种类类型转换为另一个类类型的转换规则)
    ```cpp
    string null_book = "ssss";
    // 用给定的string构造一个临时的Sales_data对象，并传入
    item.combine(null_book);
    ```

* `只允许一步类类型转换`
    ```cpp
    // 错误，因为 ssss 需要先转换成string，在把临时的string转换成Sales_data
    item.combine("ssss");

    // 正确的写法
    item.combine(string("ssss"));
    item.combine(Sales_data("ssss"));
    ```

* `类类型转换不是总有效`
    1. 是否需要上述隐式转换，依赖于我们对用户使用该转换的看法。
    ```cpp
    // 隐式的把cin转换成Sales_data，接受了一个istream的Sales_data构造函数。该构造函数通过读取标准输入创建了一个(临时的)Sales_data对象，随后将得到的对象传递给combine。
    // 这个对象是个临时量，一旦combine完成我们就不能再访问它了。
    item.combine(cin); // 构建了一个对象，先将它的值加到item中，随后将其丢弃
    ```

* `抑制构造函数定义的隐式转换`
    1. 可以通过构造函数声明为`explicit加以阻止`
    ```cpp
    class Sales_data {
    public:
        Sales_data() = default;
        // ...
        explict Sales_data(const std::string& s) : bookNo(s) {}
        explict Sales_data(std::istream&) {}
        // ...
    }

    // 以下两种隐式转换都会错误
    item.combine(null_book);
    item.combine(cin);

    // 这样是错误的，explict关键字只允许出现在类内的构造函数声明处
    explict Sales_data(std::istream&) {
        read(is, *this);
    }
    ```
    2. `关键字explict只对一个实参的构造函数有效`。需要多个实参的构造函数不能用于执行隐式转换，所以无须explict。
    3. 只能类内声明构造函数时使用`explicit`关键字，类外部定义时不应重复

* `explicit构造函数只能用于直接初始化`
    ```cpp
    // 发生隐式转换的一种情况是当我们执行拷贝形式的初始化时。这种时候，我们只能使用直接初始化而不能使用explict构造函数
    Sales_data item1(null_book);  // 正确，可以执行直接初始化
    Sales_data item2 = null_book; // 错误，不能将explict构造函数用于拷贝形式的初始化过程
    ```

* `为转换显式地使用构造函数`
    1. 尽管编译器不会将explict的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制进行转换
    ```cpp
    item.combine(Sales_data(null_book));
    item.combine(static_cast<Sales_data>(cin));
    ```

* `标准库中含有显式构造函数的类`
    1. 接受一个单参数的const char*的string构造函数不是explict的
    2. 接受一个容量参数的vector构造函数是`explict`的

### 5.5 聚合类
* `聚合类(aggregate class)`
    1. 当聚合类满足如下条件时，它是聚合的：
        1) 所有成员都是public的
        2) 没有定义任何构造函数
        3) 没有类内初始值
        4) 没有基类，也没有virtual函数
    2. 聚类例子
    ```cpp
    struct Data {
        int val;
        string s;
    };

    // 可以提供一个花括号括起来的成员初始值列表初始化聚合类的数据成员
    Data val1 = { 0, "Anna" };

    Data val1 = { "Anna", 0 }; // 错误
    ```

### 5.6 字面值常量类
// TODO 后面有需要再来看这个字面值常量类：感觉在工作中没看到用过

* `字面值常量类`
    1. 除了算术类型、引用和指针外，某些类也是字面值类型
    2. `字面值类型的类可能含有constexpr的函数成员`。这样的成员必须复合constexpr函数的所有要求，它们是隐式const的

* `constexpr构造函数`
    1. 暂时略掉，后面有空看

## 6.类的静态成员
* `声明静态成员`
    1. 场景：有时候类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。如银行账户类可能需要一个数据成员来表示当前的基准利率。
    2. 在成员的声明之前加上关键字static即可
    ```cpp
    class Account {
    public:
        void calculate() { amount += amount * interestRate; }
        static double rate() { return interestRate; }
        static void rate(double);
    private:
        std::string owner;
        double amount;
        static double interestRate;
        static double initRate();

    // 注意：静态成员函数不与任何对象绑定在一起，它们不包含this指针。
    // 作为结果，静态成员函数不能声明成const的，而且我们不能在static函数体内使用this指针

    // 网上查的：不能用const的原因：一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。
    // 而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员
    }
    ```

* `使用类的静态成员`
    ```cpp
    double r;
    r = Account::rate();

    // 虽然静态成员不属于类的某个对象，但我们仍然可以使用类的对象、引用或者指针来访问静态成员
    Account ac1;
    Account *ac2 = &ac1;
    r = ac1.rate();
    r = ac2->rate();

    // 成员函数不用通过作用域就能直接使用静态成员
    ```

* `定义静态成员`
    1. 和其他`成员函数`一样，`既可以在类的内部也可以在类的外部定义静态成员函数。`
    2. `当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部`
    3. `对于静态成员`:因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。不能再类的内部初始化静态成员。必须在类外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次

* `静态成员的类初始化`
    1. 一种特殊情况，类的静态成员可以在类内初始化。
    ```cpp
    class Account {
    public:
        static double rate() { return interestRate; }
        static void rate(double);
    private:
        // 可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr
        static constexpr int period = 30; // 如果类的内部提供了一个初始值，则成员的定义不能在指定一个初始值了
        double daily_tbl[period];
    };
    // 即使period在类内初始化了，但也应该在类的外部定义一下该成员
    constexpr int Account:period;
    ```

* `静态成员能用于某些场景，而普通成员不能`
    ```cpp
    // 场景1
    class Bar {
    public:
        // ...
    private:
        static Bar mem1;  // 正确：静态成员可以是不完全类型
        Bar *mem2;  // 正确，指针类型可以是不完全类型
        Bar mem3;   // 错误
    }

    // 场景2
    // 静态成员能作为默认实参，普通数据成员不能，因为他数据对象的一部分。
    class Screen {
    public:
        Screen& clear(char = bkground);
    private:
        static const char bkground;
    };
    ```
    