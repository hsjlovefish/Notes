# 第3章
## 目录
1. 命名空间的using声明
2. 标准库类型string
   * 定义和初始化string对象
   * string对象上的操作
   * 处理string对象中的字符
3. 标准库类型vector
   * 定义和初始化vector对象
   * 向vector对象中添加元素
   * 其他vector操作
4. 迭代器介绍
   * 使用迭代器
   * 迭代器运算
5. 数组
   * 定义和初始化内置数组
   * 访问数组元素
   * 指针和数组
   * C风格字符串
   * 与旧代码的接口
6. 多维数组
* 小结
* 术语表



----------------------------------

内置数组是一种更基础的类型，string和vector都是对它的某种抽象。
本章讲介绍两种最重要的标准库类型：string和vector。string表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。本章还将介绍内置数组类，和其他内置类型一样，数组的实现与硬件密切相关。因此相比较于标准库类型string和vector，数组在灵活性上稍显不足。

----------------------------------


# 正文
## 1.命名空间的using声明
* `using 声明及规则`
    * 有了using声明就无须专门的前缀也能使用所需的名字了
    * 形式：`using namespace::name;`  `using std::cin;` 从命名空间std中获取他
    * `头文件不应该包含using声明`，防止其他文件包含后产生名字冲突(每个使用了该头文件的文件就都会有这个声明)。对于某些程序来说，由于不经意包含了一些名字，反而可能产生始料未及的名字冲突

## 2.标准库类型string
* C++标准一方面对库类型所提供的操作做了详细规定，另一方面也对库的实现做出一些性能上的需求。因此标准库对于一般应用场合有足够的效率。

* `标准库类型string` 可变长的字符序列

### 2.1. 定义和初始化string对象
* `定义和初始化string对象`
    1. 如何初始化类的对象是由类本身决定的。一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。
    2. Code
       ```cpp
       string s1;  // 默认初始化，s1是一个空串
       string s2(s1);
       string s2 = s1; // 等价于s2(s1)
       string s3("value"); // s3是字面值"value"的副本，出了字面值最后的哪个空字符外
       string s3 = "value"; // 等价于s3("value")
       string s4(n, 'c';)  //把s4初始化为由连续n个字符c组成的串
       ``` 

* `直接初始化和拷贝初始化`
   1. 通过`等号=初始化变量`，实际上执行的`拷贝初始化`，编译器把等号右侧的值拷贝到新创建的对象中去。
   2. 如果不使用等号，则执行的是`直接初始化`
   3. 当`初始值只有一个时`，使用直接初始化或拷贝初始化都行。如果像上面如s4那样初始化要用到的`值有多个`，一般来说只能使用直接初始化的方式  
   4. 针对第三条`string s8 = string(10, 'c'); // 也可用多个值进行初始化，非要用拷贝初始化的时候(需要显示创建一个临时对象)`

### 2.2 string对象上的操作
* `string的大部分操作`
   ```cpp
   os << s; // 讲s写入当输出流中，返回os
   is >> s; // 从is中读取字符串赋给s，字符串以空白分隔，返回is
   getline(is, s); // 从is中读取一行给s，返回is
   s.empty();
   s.size();
   s[n];  // 返回s中第n个字符的引用
   s1 + s2;  // 返回s1和s2连接后的结果
   s1 = s2; // 用s2的副本代替s1中原来的字符
   s1 == s2; 
   s1 != s2; // 等性判断对字母的大小写敏感
   <, <=, >, >=； // 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
   ```

* `读写string对象`
   * 在执行读取操作时，string对象会自动忽略开头的空白(即空格符、换行符、制表符等)并从第一个真正的字符开始读起，知道遇见下一处空白为止。 

* `读取未知数量的string对象` : 
  1. `while (cin >> str)`。
  2. 如果流有效，也就是说没遇到`文件结束标记或非法输入`，那么执行while语句内部的操作。重复若干次之后，一旦遇到文件借宿标记或非法输入循环也就结束了

* `使用getline读取一整行`
  1. 有时希望能在最终得到的字符串中保留输入的空白符，这是应该getline。
  2. `getline函数的参数`是一个输入流和一个string对象，函数从给定的输入流中读入内容，直到遇到换行符为止(换行符也被读进来了)，然后把所读对象的内容存入到string对象中去(不存换行符(被丢弃了))。
  3. getline一遇到换行符就结束读取操作并发挥结果，哪怕输入的一开始就是换行符也是如此

* `string的empty和size操作`
  * empty函数根据string对象是否为空返回一个对应的布尔值
  * size返回string对象的长度(string对象中字符的个数)

* `string::size_type类型`
  1. string类及其他大多数标准库类型都定义了几种配套的类型。这种配套类型体现了标准库类型与机器无关的特性，类型size_type即是其中一种。在具体使用的时候，通过作用域操作符来表明名字`size_type是在类string中定义的`。
  2. `它是一个无符号类型的值而且能足够存放下任何string对象的大小`。
  3. 如果一条表达式中已经有了`size()函数就不要再使用int了`，这样可以避免混用int和unsigned可能带来的问题

* `比较string对象`
   * string类定义了几种用于比较字符串的运算符。这些运算符逐一比较string对象中的字符，并且对大小写敏感，也就说，在比较时同一个字母的大写形式和小写形式是不同的。

* `为string对象赋值`
   * 设置标准库类型时都力求在易用性上向内置类型看齐，因此大多数库类型都支持赋值操作。
   * 对于string类型而言，允许把一个对象的值赋给另外一个对象

* `两个string对象相加`
  * 两个string对象相加得到一个新的string对象，其内容是把左侧的运算对象与右侧的运算对象串接而成
  * 对string使用 `+` 的结果是一个新的string对象
  * `+=` : s1 += s2; --> 等价于 s1 = s1 + s2;

* `字面值和string对象相加`
   1. 即使一种类型并非所需，我们也可以使用它，不过前提是该种类那个可以自动转换成所需的类型。
   2. 因为`标准库允许把字符字面值和字符串字面值转换成string对象`，所以在需要string对象的地方就可以使用这两种字面值来替代。
   3. 当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符(+)的两侧运算对象至少有一个是string
   4. 因为历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型的对象。切记，`字符串字面值与string是不同的类型`


* `Code`
   ```cpp
   string word;
   while (cin >> word) 
      cout << word << endl;

   string line;
   while (getline(cin , line)) 
      cout << line << endl;

   while (getline(cin, line)) 
      if (!line.empty())
         cout << line << endl;

   while (getline(cin , line)) 
      if (line.size() > 80) 
            cout << line << endl;

   string s1 = "hello, ", s2 = "world\n";
   string s3 = s1 + s2;
   s1 += s2; // 等价于s1 = s1 + s2;

   string s1 = "hello", s2 = "world";
   string s3 = s1 + ", " + s2 + '\n';
   string s4 = s1 + ", ";
   string s5 = "hello" + ", "; // 错误，两个运算对象都不是string
   string s6 = s1 + ", " + "world";
   // 等价于
   string tmp = s1 + ", ";
   s6 = tmp + "world";

   string s7 = "hello" + ", " + s2; // 错误：不能把字面值直接相加 
   ```

### 2.3处理string对象中的字符
* `产生此需求的原因`
    1. 经常需要单独处理string对象中的字符，比如检查一个string对象是否包含空白，或者把string对象中的字母改成小写，再或者查看某个特定的字符是否出现等。
    2. 这类处理的一个关键问题是如何获取字符本身，有时需要处理string对象中的每一个字符，另外一些时候则只需某个特定字符，还有些时候遇到某个条件处理就要停下来。 
    3. 另外一个关键问题是要知道能改变某个字符的特性。`cctype头文件`中定义了一组标准库函数处理这部分工作。

* `cctype头文件中的函数`
   ```cpp
   isalnum(c)   // 当c是字母或数字时为真
   isalpha(c)   // 当c是字母时为真
   iscntrl(c)   // 当c是控制字符时为真
   isdigit(c)
   isgraph(c)   // 当c不是空格但可打印时为真
   islower(c)
   isprint(c)   // 当c是可打印字符时为真
   ispunct(c)   // 当c是标点符号时为真
   isspace(c)   
   isupper(c)
   isxdigit(c)
   tolower(c)
   toupper(c)
   // 建议使用c++版本的c标准库头文件
   ```

* `处理每个字符？使用基于范围的for语句`
   ```cpp
   // expression部分是一个对象，用于表示一个序列
   // declaration部分是负责定义一个变量，该变量将用于被访问序列中的基础元素。
   // 每次迭代，declaration部分的变量会被初始化为expression部分的下一个元素值
   for (declaration : expression)
      statement
   
   string str("some string");
   for (auto c : str)  // 这里c的类型是char。每次迭代，str的下一个字符被拷贝给c
      cout << c << endl;

   for (auto &c : str)
      c = toupper(c);
   cout << c << endl;
   ```

* `使用范围for语句改变字符串中的字符`
    1. 如果想要改变例如string对象中字符的值，必须把`循环变量定义成引用类型`。使用这个引用，我们就能改变它绑定的字符 
    2. 代码见上

* `只处理一部分字符`
    1.  想要访问string对象中的单个字符有两种方式：一种是`使用下标`，另外一种是`使用迭代器(3.4节 P95介绍)`
    2.  `下标运算符[]`接收的输入参数是string::size_type类型的值，这个参数表示要访问的字符的位置；`返回值`是该位置上字符的引用
    3.  下标的值称为`下标`或`索引`，任何表达式只要它的值是一个整型值就能作为索引
    4.  如果某个索引是带符号类型的值将自动转换成由string::size_type表达的无符号类型

* `使用下标执行迭代`
   ```cpp
   for (decltype(s.size()) index = 0; index != s.size() && !isspace(s[index]); ++index)
      s[index] = toupper(s[index]); //[]接收的输入参数是string::size_type
   ```

* `使用下标执行随机访问`
   ```cpp
   const string hexdigits = "0123456789ABCDEF";
   cout << "Enter a series of numbers between 0 and 15"
         << " separated by spaces. Hit ENTER when finished: "
         << endl;
   string result;
   string::size_type n;
   while (cin >> n) { 
      // 实际使用时， 需要检查n是否小于hexdigits的长度
      if (n < hexdigits.size())
            result += hexdigits[n];
   }
   cout << "Your hex number is: " << result << endl;
   ``` 

## 3.标准库类型vector(序列式容器)
* `标准库类型vector`
  * 标准库类型vector表示对象的集合，其中所有对象的类型都相同。因为vector"容纳着"其他对象，所以它也常被称作`容器(container)`
  * vector能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以`不存在包含引用的vector`。
  * vector是模板而非类型，由vector生成的类型必须包含vector中元素的类型，例如vector<int>。

* `模板`
  * C++既有类模板又有函数模板。模板不是类或者函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。`实例化`：编译器根据模板创建类或函数的过程成为实例化。。当使用模板时，需要指出编译器应把类或函数实例化成何种类型。
  * 对于类模板来说，我们通过提供一些额外的信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方法是 `模板名字后面跟一堆尖括号，在括号上放上信息`

### 3.1 定义和初始化vector对象
* `定义和初始化vector对象`
   ```cpp
   vector<T> v1;     
   vector<T> v2(v1);
   vector<T> v2 = v1;
   vector<T> v3(n, val);   // v3包含了n个元素， 每个元素的值都是val
   vector<T> v4(n);   // v4包含了n个重复执行了值初始化的对象
   vector<T> v5{a, b, c...}; /*列表初始化*/
   vector<T> v5 = {a, b, c...}; /*列表初始化*/ 
   ```

* `列表初始化vector对象`
  1. `C++11新标准`还提供了另外一种为vector对象的元素赋初值的方法，即列表初始化。此时，用花括号括起来的0个或多个初始元素值被赋给vector对象
  2. (p39 2.2.1节)：在大多情况下初始化方式可以相互等价的使用，不过也并非一直如此
        1. 使用`拷贝初始化`时(即使用=)只能提供一个初始值
        2. 如果提供的是一个`类内初始值`，则只能使用拷贝初始化或使用花括号的形式初始化。
        3. 如果提供的是`初始元素值的列表`，则只能把初始值都放在花括号里进行列表初始化，而不能放圆括号里`vector<string> v("a", "ab", "the"); // 错误`  

* `创建指定数量的元素`
  * 可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象`vector<string> svec(10, "hi!");`

* `值初始化` 
  1. `vector<int> v(n);`  此时库会创建一个`值初始化的`元素初值，并把它赋给容器中的所有元素。这个元素出只有vector对象中的元素类型来决定。
  2. 对这种初始化有两个特殊限制：
      1. 当vector对象中元素类型不支持默认初始化，必须明确提供初始值
      2. 如果只提供怨怒是的数量而没有设定初始值，只能使用直接初始化:`vector<int> vi = 10;// 错误，必须用直接初始化的形式指向向量大小` (P256 7.5.4节做更相信的介绍)

* `列表初始值还是元素数量`
    1. 如果用的是圆括号，提供的值用来`构造vector对象`
    2. 如果用的花括号，想`列表初始化vector对象`。初始化过程会尽可能把花括号内的值当成事元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。
    3. 如果使用了`花括号的形式但是提供的值不能用来列表初始化，就考虑用 圆括号的形式 提供的值 来构造vector对象`
    4. 确认`无法执行列表初始化后，编译器会尝试用默认值初始化vector对象`
    ```cpp
    vector<int> v1(10);  // 元素是10个0
    vector<int> v2{10};  // 元素是一个10

    vector<int> v3(10，1)；  // 元素是10个1
    vector<int> v4{10, 1};   // 元素是10， 1

    vector<string> v5{"hi"}; // 元素是 "hi"
    vector<string> v6("hi"); // 错误：不能使用字符串字面值构建vector对象
    vector<string> v7{ 10 }; // 10个空串，int不能初始化string
    vector<string> v8{10, "hi"}; // 10个hi，int不能初始化string
    ```  

### 3.2 向vector对象中添加元素
* `向vector对象中添加元素`
  1. push_back()
  2. 在定义vector对象的时候设定其大小可能性能会更差。除非你所有的元素值都一样。(9.4节 P317页介绍vector还提供了方法，允许进一步提升动态添加元素的性能)
  3. 如果`范围for内部`包含有向vector对象添加元素的语句，则不能使用范围for循环

### 3.3 其他vector操作
* `vector支持的操作`
   ```cpp
   v.empty()    
   v.size()  // 返回的类型是vector<int>::size_type
   // 要使用size_type，需首先指定它是由哪种类型定义的。vector对象的类型总是包含着元素的类型 vector::size_type错误
   v.push_back()
   v[n]
   v1 = v2;
   v1 = {a, b, c..}  // 用列表中的元素的拷贝替换v1的元素
   v1 == v2
   v1 != v2
   < <= > >=
   ```

* `vector的比较的规则`
  1. `关系运算符比较时`(< >之类)  依照字典顺序比较：如果两个vector对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的vector对象小于元素较多的vector对象；`类比string`
  2. 只有当元素值可比较适，vector对象才能别比较。如string可以，因为定义了相关的运算符。但Sales_item不可以

* `计算vector内对象的索引`
  ```cpp
  vector<unsigned> scores(11, 0);
  unsigned grade;
  while (cin >> grade) {
     if (grade <= 100)
      ++scores[grade / 10];
  }
  ```

* `不能用下标形式添加元素`
  * vector对象(以及string对象)的下标运算符可用于访问已存在的元素，而不能用于添加元素。
  * 用下标的形式去访问一个不存在的元素将引发错误且不被编译器发现，而是在运行时产生一个不可预知的值。
  * buffer overflow (缓冲区溢出)指的是这类错误

## 4.迭代器介绍
* `迭代器` 
  1. 所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。
  2. 迭代器提供了对对象的间接访问
  3. string对象不属于容器类型，但是string支持很多与容器类型类似的操作。
  4. 使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一元素。
  5. `迭代器有有效和无效之分`，有效的迭代器指向某个元素或者指向容器中尾元素的下一为止；其他所有情况都属于无效。

### 4.1 使用迭代器
* `begin() , end()成员`
  1. 获取迭代器不是使用取地址符
  2. begin返回指向第一个元素的迭代器
  3. end返回`尾后迭代器`
  4. 如果容器为空，则begin和end返回的是同一个迭代器，都是尾喉迭代器
  5. C++ for循环中习惯使用 != == (因为标准库容器的迭代器都定义了== 和 !=，但它们中的大多数都没有定义<运算符)
  6. `C++11新标准`引入了两个新函数cbegin和cend。两者不管对象本身是否是常量，返回值都是const_iterator

* `标准容器迭代器的运算符`
   * Code
      ```cpp
      *iter //返回迭代器iter所值元素的引用
      iter->mem //解引用iter并获取该元素名为mem的成员，等价于(*iter).mem
      ++iter
      --iter
      iter1 == iter2
      iter1 != iter2
      ```
   * 执行解引用的迭代器必须合法并确实指示着某个元素。

* `将迭代器从一个元素移动到另外一个元素`
  1. 可以使用`++` or `--`
  2. 因为end返回的迭代器并不实际只是某个元素，所以不饿能对齐进行递增或解引用的操作

* `迭代器类型`
  1. 有`const_iterator`，类似于指向常量的指针，能读取但不能修改它所指的元素值
  2. 有`iterator`
  3. 如果vector对象是常量，只能使用const_iterator；如果vector不是常量，既可以用iterator又可以用const_iterator

* `结合解引用和成员访问操作`
  1. `(*it).mem  !=  *it.mem`
  2. 为了简化上述表达式，C++语言定义了箭头运算符(`->`)。箭头运算符`把解引用和成员访问两个操作结合在一起`。 
  3. `(*it).mem == it->mem`

* `某些对vector对象的操作会使迭代器失效`
  * `vector可动态的增长`，但1.不能在范围for中向vector添加元素   2.改变vector对象容量的操作如push_back等会使得vector的迭代器失效
  * 凡是使用了迭代器的循环体，都不要想迭代器所属的容器添加元素

### 4.2.迭代器运算(iterator arithmetic)
* `vector和string迭代器支持的运算`
   ```cpp
   iter + n
   iter - n
   iter1 += n
   iter2 -= n
   iter1 - iter2  //得到difference_type 带符号整型数
   > >= < <=
   ```

* `迭代器的算术运算`
   1. `difference_type`:vector和string都定义了difference_type；由两个同一容器的迭代器相减所得，是两个迭代器距离的大小。


* `使用迭代器运算`
  * `使用迭代器二分搜索`
   ```cpp
   auto beg = text.begin(), end = tex.end();
   auto mid = text.begin() + (end - beg) / 2;
   while (mid != end && *mid != sought)
   {
      if (sought < *mid)
         end = mid;
      else
         beg = mid + 1;
      mid = beg + (end - beg) / 2;
   }
   ```

## 5.数组
* 与vector类似的地方是，数组也是存放类型相同的对象的容器。
* 数组大小固定，对某些特殊的应用来说程序的运行时性能较好，但缺乏灵活性。

### 5.1 定义和初始化内置数组
* `定义和初始化数组`
  1. 数组的声明 a[d] a是数组的名字，d是数组的维度。
  2. 数组的元素的个数也属于数组类型的一部分，`编译的时候维度应该是已知的`。也就是说，维度必须是一个`常量表达式`
  3. 默认情况下，数组的元素被默认初始化(如果是内置类型且在函数体内，则会有未定义的值)
  4. 定义数组的时候不允许使用`auto`
  5. 和vector一样，数组的元素应为对象，因此不存在引用的数组
   ```cpp
   unsigned cnt = 42; // 不是常量表达式
   constexpr unsigned sz = 42; // 是常量表达式
   int arr[10];
   int *parr[sz];
   string bad[cnt]; // 运行通过，但书本上却说错误
   string strs[get_size()]; //当get_size是constexpr时正确；否则错误
   ``` 

* `显示初始化数组元素`
   1. 可以对数组元素进行列表初始化，此时允许忽略数组的维度。编译器自动推断维度。
   2. 如果指明维度，那么初始值的总数量不应该超出指定的大小。如果维度大于提供的初始值数量，靠后的元素执行默认初始化。
   ```cpp
   const unsigned sz = 3;
   int ial[sz] = {0 ,1 ,2};
   int a2[] = {0, 1, 2};
   int a3[5] = {0, 1, 2}; // 0 1 2 0 0注意后面是0 0
   string a4[3] = {"hi", "bye"};
   int a5[2] = {0, 1, 2}; // 错误，初始值过多
   ```

* `字符数组的特殊性`
  * 字符数组可以用字符串字面值初始化，但当用这种方式时，结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去。
   ```cpp
   char a1[] = {'C', '+'}; // 没有空字符， 大小为2
   char a2[] = {'C', '+', '\n'}; // 有显示的空字符
   char a3[] = "C++"; // 自动添加空字符 大小为4
   const char a4[6] = "Daniel"; // 错误：没有空间可存放空字符！
   char a[5] = "an"; // 合法
   ``` 

* `数组不允许拷贝和赋值`
  1. 不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值
  2. 有些编译器支持数组的赋值，但这不是标准特性，不建议用
   ```cpp
   int a[] = {0, 1, 2};
   int a2[] = a; // 错误，不允许使用一个数组初始化另一个数组
   a2 = a; // 表达式必须是可修改的左值；  不能把一个数组直接赋值给另一个数组
   ``` 

* `理解复杂的数组声明`
  1. 与vector一样，`数组能存放大多数类型的对象`，如果定义一个存放指针的数组
  2. `数组本身就是对象`，允许定义数组的指针及数组的引用。
  3. `默认情况下，类型修饰符由右向左一次绑定`。`对于ptrs`，右向左理解含义比较简单。`对于Parray`来说，从右向左理解就不太合理。所以`由内向外阅读`要比右向左好。
   ```cpp
   int arr[10];
   int *ptrs[10]; // ptrs时含有10个整型指针的数组
   int &refs[10]; // 数组里不能放引用
   cout << arr << endl;
   cout << &arr << endl;
   int (*Parray)[10] = &arr; // Parray指向一个含有10个整数的数组
   int (&arrRef)[10] = arr; // arrRef引用一个含有10个整数的数组
   int *(&arry)[10] = ptrs; // arry是数组的引用，该数组含有10个int型指针
   ``` 


### 5.2 访问数组元素
* `访问数组元素`
  1. 数组元素可以用`范围for语句`或`下标运算符`来访问
  2. 使用数组下标时候，通常将其定义为`size_t类型`。size_t是一种机器相关的无符号类型，他被设计的足够大以便能够表示内存中任意对象的大小。
  3. size_t`在cstddef头文件中定义` 

* `Code`
   ```cpp
   unsigned scores[11] = {}; // 11个0，列表初始化是0
   unsigned grade;
   for (auto i : scores)
      cout << i << " "; // 0 0 0 0 0 0 0 0 0 
   while (cin >> grade) {
      if (grade <= 100)
         ++scores[grade / 10];
   }
   for (auto i : scores) // 因为维度是数组类型的一部分，所以系统知道数组scores中有多少个元素。
      cout << i << " ";
   ```

* `检查下标的值`
  1. 下标大于等于0且小于数组的小大
  2. 编译器检查不了，只能测试或注意细节 

### 5.3 指针和数组
* `指针和数组`
  1. C++中，指针和数组有很紧密的联系。如使用数组的时候编译器一般会把它转换成指针 
  2. 允许使用取地址符获取数组的元素，可得到指向该元素的指针
  3. `数组的名字`编译器会替换成指向数组首元素的指针(在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针)
  4. 当数组作为一个`auto变量`的初始值时，推断得到的`类型`是指针而非数组；而`decltype`时候，返回的`类型`是由10个整数构成的数组
   ```cpp
   string nums[] = {"one", "two", "three"};
   string *p = &nums[0];
   string *p2 = nums; // 等价于上一条语句

   int ia[] = {0,1,2,3,4,5,6,7,8,9};
   auto ia2(ia); // ia2是一个整型指针，指向ia的第一个元素
   // 等价于 auto ia2(&ia[0]);
   // ia2 = 42; // 错误，不能用int值给指针赋值

   decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
   // ia3 = p; 错误：不能用整型指针给数组赋值
   int i = 0;
   ia3[4] = i;
   ``` 

* `指针也是迭代器`
   1. vector和string迭代器支持的运算，数组的指针全都支持
   2. 使用指针也能遍历数组中的元素，前提是得到指向首元素的指针和尾元素下一个位置的指针
   3. `数组的一个特殊性质` 可以对尾元素下一个位置取值，得到`尾后指针`：不能对尾后指针执行解引用或递增的操作
   ```cpp
   int arr[] = {0,1,2,3,4,5,6,7,8,9};
   int *p = arr;
   ++p;
   int *e = &arr[10]; // 不能对尾后指针执行解引用或递增的操作
   for (int *b = arr; b != e; ++b)
      cout << *b << endl;
   ``` 

* `标准库函数begin和end`
   1. 得到尾后指针用法容易出错。C++11引入了`begin和end函数`，定义在iterator头文件中
   2. begin返回指向数组首元素的指针，end返回指向数组尾元素下一个位置的指针
   3. begin和end必须在编译器能确定数组维度的时候使用
   ```cpp
   int ia[] = {0,1,2,3,4,5,6,7,8,9};
   int *beg = begin(ia);
   int *last = end(ia);
   // 直到数组中第一个负值元素
   while (beg != last && *beg >= 0)
      ++beg;
   ``` 

* `指针运算`
   1. 指向数组元素的指针在`解引用、递增、比较、与整数相加、两个指针相减`等，用在指针和用在迭代器意义完全一致。
   2. 给一个指针加上or减去某整数值。结果仍然是指针。新指针元素与原来的指针相比前进了(后退了)该整数值个位置
   3. `ptrdiff_t`类型，定义在cstddef头文件的机器相关的类型。带符号类型。由两个指针相减的结果所得(差值可能为负)
   ```cpp
   constexpr size_t sz = 5;
   int arr[sz] = {1,2,3,4,5};
   int *ip = arr; // ip->arr[0]
   int *ip2 = ip + 4; // ip2->arr[4]

   int *p = arr + sz; // p->arr[5];
   int *p2 = p + 10; // 错误，p2值未定义。编译器检查不出来

   auto n = end(arr) - begin(arr); // ptrdiff_t类型

   int *b = arr, *e = arr + sz;
   while (b < e) {
      // do something
      ++b;
   }

   // 如果两个指针分别指向不相关的对象，则不能比较它们
   int i = 0, sz = 42;
   int *p = &i, *e = &sz;
   while (p < e)  //无意义
   // void *a = &i, *b = &sz;
   // while (a < b); // 无意义
   ``` 

* `解引用和指针运算的交互`
  1. 指针加上一个整数所得的结果还是一个指针。如果指针指向了一个元素，则允许解引用该结果指针
  ```cpp
  int ia[] = {1, 2, 3, 4 ,5};
  int last = *(ia + 4); // ia[4]
  last = *ia + 4; // ia[0] + 4
  ```  

* `下标和指针`
   1. 使用`数组的名字`用的是`指向数组首元素的指针`。当对`数组使用下标运算符`时，编译器会自动执行上述转换操作。
   2. `指针是指向数组中的元素`,都可以执行下标运算
   3. vector和string也能执行下标运算，他们下标必须是无符号类型。而内置的下标运算无此要求。数组用的内置的。这一点和vector和string不一样
   ```cpp
   int ia[] = {1, 2, 3, 4 ,5}; 
   // ia[0]是使用了数组名字的表达式
   // 对数组执行下标运算其实是对指向数组元素的指针执行下标运算
   int i = ia[2];  // *(ia + 2)
   int *p = ia;
   i = *(p + 2); // 等价于 i = ia[2];

   // 只要指针指向的是数组中的元素(或指向数组中的为元素的下一位置)，都可执行下标运算。
   int *p = &ia[2];
   int j = p[1];  // ia[3]
   int k = p[-2]; // 表示ia[0];
   ``` 

### 5.4 C风格字符串
* `c风格字符串`
  1. 尽管c++支持c风格字符串，但在c++程序中最好还是不要使用它们。这是因为c风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。
  2. 字符串字面值就是c风格字符串，会在字符串的最后一个字符后面跟着一个空字符`'\0'`

* `C标准库String函数`
  1. 定义在cstring头文件中
      ```cpp
      // c风格字符串的函数
      strlen(p); // 返回p的长度
      strcmp(p1, p2) // p1 > p2  返回正值， == 返回0，p1 < p2，返回负值
      strcat(p1, p2) //将p2拼在p1之后，返回p1
      strcpy(p1, p2) // 将p2拷贝给p1，返回p1      
      ```
   2. 传入此类函数的指针必须指向以空字符作为结束的数组
      ```cpp
      char ca[] = {'c', '+', '+'}; // 不以空字符结束
      cout << strlen(ca) << endl; // 严重错误，ca没有空字符结束。
      // strlen函数将可能沿着ca在内存中的位置不断向前寻找，直到遇到空字符 
      ``` 

* `比较字符串`
   * strcmp(p1, p2);

* `目标字符串的大小由调用者指定`
  * 记得指定要拼接的字符串的大小，如果大小不对将引发严重错误
     ```cpp
      const char ca1[] = "hhhh";
      const char *ca2 = "aaaa";
      cout << *ca2 << endl; // 可看出const char *和[] 的区别
      strcmp(ca1, ca2);
      // strcat(ca1, ca2); // 第一个参数必须是变量
      char largeStr[15];
      strcpy(largeStr, ca1);
      strcat(largeStr, " ");
      strcat(largeStr, ca2);
      cout << largeStr << endl;
      char *index = largeStr;
      while (index && *index != '\0') {
         cout << *index;
         index++;
    }
      ```  
   * 大多数应用，标准库string比c风格字符串更安全高效

### 5.5 与旧代码的接口
* `混用string对象和C风格字符串`
  1. 任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代；反过来不能用string替代C风格字符串
  2. 允许使用以空字符节俗的字符数组来初始化string对象或为string对象赋值。
  3. 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象(不能两个运算对象都是)；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。 
  4. c_str(); 返回const char *     `const char *str = s.c_str();`。注意当s改变了，str可能失去作用

* `使用数组初始化vector对象`
  1. 不允许使用一个数组为另一个数组赋值，不允许使用vector对象初始化数组
  2. 允许使用数组初始化vector对象，只需首元素地址和尾后地址 
   ```cpp
   int int_arr[] = {0, 1, 2, 3, 4, 5};
   vector<int> ivec(begin(int_arr), end(int_arr));
   vector<int> subVec(int_arr + 1, int_arr + 4); // int_arr[1]  int_arr[2]  int_arr[4]
   ``` 

## 6.多维数组
* `多维数组`
  1. 严格来说，C++多维数组其实就是数组的数组。
  2. 当一个数组的元素任然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素(也是数组)大小 

* `多维数组的初始化`
  1. 允许使用花括号括起来的一组值初始化多维数组
  ```cpp
  int ia[3][4] = {
      {0,1,2,3},
      {4,5,6,7},
      {8,9,10,11}
   };
   // 内嵌的花括号并非必要 ->等价于
   int ia2[3][4] = {0,1,2,3,4,5,6,7,8,9};

   // 如果仅仅想初始化每一行的第一个元素，其他未列出的元素执行默认初始化
   int ia3[3][4] = {{0}, {4}, {8}};

   // 它仅仅初始化第一行的4个元素
   int ia4[3][4] = { 0, 3, 6, 9 };
  ```

* `多维数组的下标引用`
  1. 可以使用下标运算符来访问多维数组的元素，数组的每个维度对应一个下标运算符
  2. 如果`维度一样多`，结果是给定类型的元素 。如果维度小，结果是给定索引处的一个内层数组
  3. 程序中经常会用到两层嵌套的for循环来处理多维数组的元素
   ```cpp
   ia[2][3] = arr[0][0][0];
   int (&row)[4] = ia[1]; // 把row绑定到ia的第二行

   constexpr size_t rowCnt = 3, colCnt = 4;
   int ia5[rowCnt][colCnt];
   for (size_t i = 0; i != rowCnt; ++i) {
      for (size_t j = 0; j != colCnt; ++j) {
         ia5[i][j] = i * colCnt + j; // 该元素的在数组中的序号
      }
   }
   ```

* `使用范围for语句处理多维数组 C++11新标准`
  1. 要使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。
   ```cpp
   size_t cnt = 0;
   for (auto &row : ia) {
      for (auto &col : row) {
         col = cnt;
         ++cnt;
      }
   }
   // 不改变元素时候
   for (const auto &row : ia) {
      for (auto col : row) {
         cout << col << endl;
      }
   }
   // 没有写操作时，还是将外层循环的控制变量声明称了引用类型，为了避免数组被自动转化成指针
   for (auto row : ia) { // row被转换成了指向该数组内首元素的指针  int *..... 分别变成ia[0]  ia[1]  ia[2]数组内的首元素
      // for (auto col : row);   // 编译器试图在一个 int *内遍历，显然不合法。 
   }
   ``` 

* `指针和多维数组`
  1. 当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针(第一个内层数组的指针) 
   ```cpp
   int ia6[3][4];
   int (*p)[4] = ia;
   p = &ia[2];

   for (auto p = ia6; p != ia6 + 3; ++p) { // p指向含有4个整数的数组
      for (auto q = *p; q != *p + 4; ++q) // q指向一个整数
         cout << *q << ' ';
      cout << endl;
   }
   for (auto p = begin(ia6); p != end(ia); ++p) { // p指向ia的第一个数组
      for (auto q = begin(*p); q != end(*p); ++q) // q指向内层数组的首元素
         cout << *q << ' ';
      cout << endl;
   }
   ``` 

* `类型别名简化多维数组的指针`
  1. 读写和理解一个指向多维数组的指针是一个让人不胜其烦的工作，使用类型别名能让这项工作变得简单一点
   ```cpp
   using int_array = int[4]; // 两者等价
   typedef int int_array[4]; // 两者等价
   for (int_array *p = ia6; p != ia6 + 3; ++p) {
      for (int *q = *p; q != *p + 4; ++q) 
         cout << *q << ' ';
      cout << endl;
   }
   ```  

## 小结
## 术语表
