# 第4章
# 目录
1. 基础
   * 基本概念
   * 优先级与结合律
   * 求值顺序
2. 算术运算符
3. 逻辑和关系运算符
4. 赋值运算符
5. 递增和递减运算符
6. 成员访问运算符
7. 条件运算
8. 位运算符
9. sizeof()运算符
10. 逗号运算符
11. 类型转换
    * 算术类型
    * 其他隐式转换
    * 显示转换  
12. 运算符优先级
* 小结
* 术语表

----------------------------------

C++语言提供了一套丰富的运算符，并定义了这些运算符作用域内置类型的运算对象时所执行的操作。当运算对象是类类型时，C++语言也允许由用户指定上述运算符的含义。
本章主要介绍由语言本身定义、并用于内置类型运算对象的运算符，同时简单介绍几种标准库定义的运算符。

----------------------------------

# 正文
表达式由一个或多个`运算对象`组成，对表达式求值将得到一个`结果`。字面值和变量是最简单的`表达式`，其结果就是字面值和变量的值。把一个`运算符`和一个或多个运算对象组合起来可以生成较复杂的表达式。

## 1.基础
有几个基础概念对表达式的求值过程有影响，它们涉及大多数(甚至全部)表达式。

### 1.1 基本概念
* `运算符`
  1. c++定义了`一元运算符`和`二元运算符`
  2. 区别运算符在它们作用的对象的个数
  3. 一个符号到底是一元还是二元由上下文决定 如*

* `组合运算符和运算对象`
  1.  如果要理解有多个运算符的复杂表达式，需要理解运算符的`Y优先级``结合律``求值顺序`

* `运算对象转换`
  1. 一种类型转换为另一种类型
  2. 小整数类型通常会被`提升`成较大的整数类型

* `重载运算符`
  1. 当运算符作用域类类型的运算对象时，用户可以自行定义其含义。
  2. 运算对象的个数、运算符的优先级和结合律是无法改变的

* `左值和右值`
  1. `C++的表达式要不然是右值、要不然就是左值。`
  2. C++中，一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值句的左侧运算对象。
  3. 此外，虽然某些表达式的求值结果是对象。但它们是右值而非左值。(`匿名对象？`)
  4. `一个简单的归纳`：当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）
  5. `一个重要的原则`：在需要右值的地方可以用左值来代替，但是不能把右值当成左值来（也就是位置）使用。当一个左值被当成右值使用的时候，实际使用的是它的内容`（13.6节，P470有种例外情况）`
  6. `目前为止学的运算符要用到的左值的`
     1. `赋值运算符`需要用到左值运算符作为左侧运算对象，得到的结果也任然是一个左值
     2. `取地址符`作用与一个左值运算对象，返回一个指向该算符符对象的指针，这个指针是一个右值
     3. `内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符`的求值结果都是左值
     4. `内置类型和迭代器的递增递减运算符`作用于左值运算对象，其前置版本所得的结果也是左值
     5. `decltype`如果表达式的求值结果是左值，得到引用。如果是是右值见下。
     6. `p 是int *``decltype(*p)  = int&     decltype(&p) = int**` 

### 1.2 优先级与结合律
* `复合表达式` 
  * 含有两个或或多个运算符的表达式。
  * 求复合表达式的值首先需要将运算符和运算对象合理地组合在一起。

* `括号无视优先级于结果率`
  1. 表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合

* `优先级与结合律有何影响`
  * 算术运算符满足左结合律，如果运算符优先级相同，讲按照从左向右的顺序组合运算对象
  * `如果优先级相同`，其组合规则由`结合律确定`
  * 优先级可能影响程序的正确性
  * 结合律的例子:IO相关的运算符，如`cin >> v1 >> v2;`

### 1.3 求值顺序
* `优先级`
  * 规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数的情况下，不会明确指定求值顺序
  * 对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，可能会引发错误并产生未定义的行为
  * `code`
    ```cpp
    int i = f1() * f2(); // 不知道哪个先被调用
    int i = 0;
    cout << i << " " << ++i << endl; //这种就是未定义的 可能是 0 1 可能是 1 1 这种行为不可预知

    f() + g() * h() + j(); // 函数调用顺序没有明确确定，如果这几个函数影响同一个对象，则为一条错误的表达式，为未定义行为
    ```
  * 有4种运算符明确规定了运算对象的求值顺序
    1. 逻辑与`&&`，它先规定先求左侧运算对象的值
    2. 逻辑或
    3. 条件运算符 ` ? : `
    4. 逗号运算符 

* `求值顺序、优先级、结合律`
  1. `运算对象的求值顺序与优先级和结合律无关` 
  2. 例子见上面code

## 2.算术运算符
`算术运算符的结果都是右值`

## 3.逻辑和关系运算符
`运算对象和求值结果都是右值`

## 4.赋值运算符
`赋值运算符的左侧运算对象必须是一个可修改的左值`
* 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换为左侧运算对象的类型。
* 赋值运算符满足右结合律 ival = jval = 0；
* 赋值运算符优先级较低
* 切勿混淆相等运算符和辅助运算符
* 复合赋值运算符只求值一次，普通求值两次 += -=

## 5.递增和递减运算符
`这两种运算符必须作用与左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回`
建议：除非必须，否则不用递增递减运算符的后置版本。 *p++ == *(p++)因为++运算符优先级较高

## 6.成员访问运算符
`箭头作用于一个指针类型的运算对象，结果是一个左值`
`点运算符分两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属对象是右值，那么结果是右值`

## 7.条件运算符

## 8.位运算符

## 9.sizeof运算符

## 10.逗号运算符

## 11.类型转换
* 隐式转换
* 显示转换（强制类型转换）
  `cast-name<type(expression)>`
1. static_cast
2. dynamic_cast 支持运行时类型识别(19.2 p730)
3. const_cast
4. reinterpret_cast

static_cast ：可以使用这种转换找回void* 指针的值。   只要不包含底层const。
const_cast ：只能改变运算对象的底层const：去掉const性质。
reinterpret_cast ：为运算对象的位模式提供较低层次上的重新解释。

## 12.运算符优先级

## 小结
## 术语表