# 第15章
# 目录
1. OOP: 概述
2. 定义基类和派生类
    * 定义基类
    * 定义派生类
    * 类型转换与继承
3. 虚函数
4. 抽象基类
5. 访问控制与继承
6. 继承中的类作用域
7. 构造函数与拷贝控制
    * 虚析构函数
    * 合成拷贝控制与继承
    * 派生类的拷贝控制成员
    * 继承的构造函数
8. 容器与继承
    * 编写Basket类
9. 文本查询程序再探
    * 面向对象的解决方案
    * Query_base类和Query类
    * 派生类
    * eval函数
* 小结
* 术语表

> 面向对象程序设计基于三个基本概念: `数据抽象、继承和动态绑定`(这也是核心思想)
> 继承和动态绑定对程序的编写有两方面影响：一是我们可以更容易地定义与其他类相似但不完全相同的新类；二是在使用这些彼此相似的类编写程序时，我们可以在一定程度上忽略掉它们的区别

## 1.OOP: 概述
* `面向对象程序设计`
    1. 通过使用数据抽象，我们可以将类的接口和实现分析
    2. 使用继承，可以定义相似的类型并对其相似关系建模
    3. 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象

* `继承`
    1. 通过`继承inheritance`练习在一起的类构成一种层次关系。`基类base class、派生类derived class`
    2. 在c++语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本,此时基类就将这些函数声明成`虚函数 virtual function`
    3. 派生类使用`类派生列表(class derivation list)`明确指出它是从那个(些)基类继承而来的.派生类必须在其内部对所有重新定义的虚函数进行声明。记得加`override关键字`

* `动态绑定`
    1. dynamic binding. 运行函数的版本由指向的对象决定，即在运行时选择函数的版本，有时又被称为运行时绑定(run-time binding)
    2. 在c++语言中，当我们使用基类的引用(或指针)调用一个虚函数时将发生动态绑定

## 2.定义基类和派生类
### 2.1 定义基类
* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此`virtual ~Quote() = default;`

* `成员函数与继承`
    1. c++中，基类必须将两种成员函数区分开来，一种是基类希望其派生类进行覆盖的函数(通常定义为虚函数)，另一种是基类希望派生类直接继承而不要改变的函数
    2. 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时

* `访问控制与继承`
    1. 派生类可以继承定义在基类的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，不能访问私有成员。
    2. protected可以禁止其他用户访问，但派生类有权访问该成员

### 2.2 定义派生类
> 大多数类都只继承一个类，这种形式的继承被称作`单继承`，这是本章的主题。关于多继承在18.3节P710页介绍

* `派生类中的虚函数`
    1. 派生类经常(但不总是)覆盖它继承的虚函数.如果派生类没有覆盖其基类中的某个虚函数,则该虚函数的行为类似于其他的普通成员,派生类会直接继承其在基类中的版本
    2. 可以在覆盖的函数前使用virtual，但做了没啥用。c++11允许显式的使用某个成员函数覆盖它继承的虚函数(override)

* `派生类对象及派生类向基类的类型转换`
    1. 在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。(一般连续的是概念模型，而非物理模型)
    2. 因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能`将基类的指针或引用绑定到`派生类对象中的基类部分上(`这种转换通常称为派生类到基类(derivied-to-base)的类型转换。和其他类型住哪换一样，编译器会隐式地执行派生类到基类的转换`)
    3. 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在

* `派生类构造函数`
    1. `尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。`和其他创建了基类对象的代码一样，`派生类也必须使用基类的构造函数来初始化它的基类部分`
    2. `每个类控制它自己的成员初始化过程！！！`
    3. `派生类对象的基类部分`与`派生类对象`自己的数据成员都是在构造函数的初始化阶段执行初始化操作的
    ```cpp
    // 派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的
    Bulk_quote(const std::string &book, double p,
        std::size_t qty, double disc) :
        Quote(book, p), min_qty(qty), discount(disc) { }
    
    // 除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化
    // 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。
    // 这个实参列表将帮助编译器决定到底应该选用俺哥构造函数来初始化派生类对象的基类部分
    ```
    4. 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

* `派生类使用基类的成员`
    1. 必须明确的一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此
    2. 派生类对象不能直接初始化基类的成员。虽然能在构造函数内修改基类public、protected成员的值，但不要这么玩
    3. 和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员

* `继承与静态成员`
    1. 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义

* `派生类的声明`
    1. 派生类的声明和其他类差别不大，声明中包含类名但是不包含它的派生列表

* `被用作基类的类`
    1. 略

* `防止继承的发生`
    1. 有时我们会定义这样一种类，我们不希望其他类继承它，或者不想考虑它是否适合作为一个基类。`用final`
    ```cpp
    class NoDerived final {};
    class Last final : Base {};
    // 使用class默认继承方式是private，使用struct时默认的继承方式是public，不过最好显式地写出继承关系
    ```

### 2.3 类型转换与继承
> 和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以讲一个派生类对象的指针存储在一个基类的智能指针内

* `静态类型与动态类型`
    1. 当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的`静态类型(static type)`与该表达式表示对象的`动态类型(dynamic type)`区分开来。
    2. 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成类型。动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知

* `不存在从基类向派生类的隐式类型转换...`
    1. 之所以存在派生类向积累的类型转换 是因为 每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上
    2. `因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换`
    3. 编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法
    4. 如果在基类中含有一个或多个虚函数，我们可以使用dynamic_cast请求一个类型转换，该转换的安全检查将在运行时执行
    5. 如果我们已知某个基类向派生类的转换是安全的,则我们可以使用static_cast来强制覆盖掉编译器的检查工作

* `...在对象之间不存在类型转换`
    1. 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉(`切掉sliced down`)

* `关键概念, 理解继承关系之间类的类型转换`
    1. 从派生类向基类的类型转换只对指针或引用有效
    2. 基类向派生类不存在隐式类型转换
    3. 和其他任何成员一样，派生向基类的类型转换也可能会由于访问受限而变得不可行(15.5节 P544详细介绍可访问性的问题)
    
## 3.虚函数
> c++中，当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能之道到底调用了那个版本的虚函数
> 通常情况下，如果我们不使用某个函数，则无须为该函数提供定义，`但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用那个虚函数`

* `对虚函数的调用可能在运行时才被解析`
    1. 编译的代码直到运行时才能确定应该调用哪个版本。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个
    2. OOP的核心思想是多态性(polymorphism)。该词源自希腊语，其含义是多种形式

* `派生类中的虚函数`
    1. 派生类中的虚函数的返回类型必须与基类函数匹配
    2. 例外，当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。
    ```cpp
    class D : B;
    // 基类的虚函数可以返回B*，而派生类的对应函数可以返回D*，只不过这样的返回类型要求从D到B的类型转换是可访问的
    ```

* `final和override说明符`
    1. 如果有覆盖基本版本的虚函数的意图，最好加上override，避免很多调试问题
    2. 如果override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错
    3. 我们还能把某个函数指定为final，则之后任何尝试覆盖该函数的操作都将引发错误`void func(int) const final;`

* `虚函数与默认实参`
    1. 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致

* `回避虚函数的机制`
```cpp
// 在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本
// 使用 作用域运算符 可以实现这一目的
double undiscounted = baseP->Quote::net_price(42);

// 通常情况下，只有成员函数(或友元)中的代码才需要使用作用域运算符来回避虚函数的机制

// 如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归
```

## 4.抽象基类
* `纯虚函数`
    1. 和普通函数不一样，一个纯虚函数无须定义。通过在函数体的位置书写=0就可以讲一个虚函数说明为纯虚函数。=0 只能出现在类内部的虚函数声明语句处
    2. 其实可以为虚函数提供定义，不过函数体必须定义在类的外部

* `含有纯虚函数的类是抽象基类(abstract base class)`
    1. 我们不能创建抽象基类的对象   ps:记得是可以使用抽象基类的指针或引用？

* `派生类构造函数只初始化它的直接基类`
    1. class A; class B : A; class C : B;
    2. B是C的直接基类，A是C的间接基类

* `重构`
    1. 在Quote的继承体系中增加Disc_quote类(有纯虚函数)是重构的一个典型示例。重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中
    2. 即使我们改变了整改继承体系，那些使用了bulk_quote或Quote的代码也无须进行任何改动

## 5.访问控制与继承
> 每个类分别控制自己的成员初始化过程，与之类似，每个类还分别控制着其成员对于派生类来说是否`可访问(accessible)`

* `受保护的成员`
    1. protected来声明它希望与派生类分享但不想被其他公共访问使用的成员
    2. 派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限

* `公有、私有和受保护继承`
```cpp
class Base {
public:
    void pub();
protected:
    int prot;
private:
    char priv;
};

class A : public Base {
    // 正确
    int f() { return prot; }

    // 错误，private不可访问
    int g() { return priv; }
};

class B : private Base {
    // !!! private不影响派生类的访问权限
    int f1() const { return prot; }
};

// 派生访问说明符 对于派生类的成员(及友元)能否访问其直接基类的成员没什么影响

// 对基类成员的访问权限只与 基类中的访问说明符 有关 !!!

// !!! 派生类访问说明符的目的是 控制派生类用户(包括派生类的派生类在内)对于基类成员的访问权限
```

* `派生类向基类转换的可访问性`
    1. 派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。
    2. 假定D继承自B: 1) 只有当D公有地继承B时，用户代码才能使用派生类向基类的转换；如果D继承B的方式是受保护的或者私有的，则用户代码不能使用该转换 2) 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的 3) 如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，私有的，则不能使用`这段话没搞懂`

* `友元和继承`
    1. 友元关系不能传递，也不能继承。积累的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员
    ```cpp
    class Base {
        friend class Pal;
    };

    class Pal {
    public:
        int f(Base b) { return b.prot_mem; }     // 正确
        int f2(Sneaky s) { return s.j; }         // 错误 pal不是Sneaky的友元
        int f3(Sneaky s) { return s.prot_mem; }  // 正确

    };
    ```
    2. 每个类负责控制各自成员的访问权限

* `改变个别成员的可访问性`
```cpp
// 有时我们需要改变派生类继承的某个名字的访问级别，通过使用using声明达到这一目的
// 派生类只能为那些它可以访问的名字提供using声明
class Base {
public:
    std::size_t size() const { return n; }
protected:
    std::size_t n;
};

class Derived : private Base {
public:
    // 保持对象尺寸相关的成员的访问级别
    using Base::size;
protected:
    using Base::n;
};
```

* `默认的继承保护级别`
    1. stcut和class关键字定义的类具有不同的 默认访问说明符 
    2. 默认派生运算符，class是私有继承，stuct是公有继承

## 6.继承中的类作用域
> 每个类定义自己的作用域，在这个作用域内我们定义类的成员。`当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内`。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义

* `在编译时进行名字查找`
    1. 一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的.即使静态类型与动态类型可能不一致，但是我们能使用哪些成员仍然是由静态类型决定的(`即指针就是静态类型，他只能访问指针的类型的成员`)

* `名字冲突与继承`
    1. 和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域的名字将隐藏定义在外层作用域(即基类)的名字(`即 派生类的成员将隐藏同名的基类成员`)

* `通过作用域运算符来使用隐藏的成员`
    1. 如题，被隐藏的成员可以用作用域访问
    2. 其实，除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字
    ```cpp
    p->mem()  p.mem()
    // 发生的事情

    // 1. 首先确定p的静态类型，因为调用的是一个成员，所以该类型必须必然是类类型

    // 2. 在p的静态类型对应的类中查找mem。找不到上层作用域找。最后找不到编译器报错

    // 3. 找到了mem，就进行常规的类型检查以确认对于当前找到的mem，本次调用是否合法

    // 4. 假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码
    // 如果是，编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型
    // 反之，不是的话，产生一个常规函数调用
    ```

* `一如往常，名字查找先于类型检查`
    1. 声明在内层作用域的哈数并不会重载声明在外层作用域的函数。因此，定义派生类的函数也不会重载其基类中的成员。如果重名，则隐藏基类的成员，即使派生类成员和基类成员的形参列表不一致

* `虚函数与作用域`
    1. 为什么基类与派生类中的虚函数必须有相同的形参列表。假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了
    ```cpp
    class Base {
    public:
        virtual int fcn() {
            cout << __LINE__ << " " << __func__ << endl;
            return 0;
        }
    };

    class D1 : public Base {
    public:
        int fcn(int) {  // 会隐藏fcn
            cout << __LINE__ << " " << __func__ << endl;
            return 0;
        }

        virtual void f2() {
            cout << __LINE__ << " " << __func__ << endl;
        }
    };

    class D2 : public D1 {
    public:
        int fcn(int) {
            cout << __LINE__ << " " << __func__ << endl;
            return 0;
        }

        int fcn() {
            cout << __LINE__ << " " << __func__ << endl;
            return 0;
        }

        void f2() {
            cout << __LINE__ << " " << __func__ << endl;
        }
    };

    Base bobj;
    D1 d1obj;
    D2 d2obj;

    Base *bp1 = &bobj, *bp2 = &d1obj, *bp3 = &d2obj;
    bp1->fcn();   // base::fcn
    bp2->fcn();   // base fcn    // 通过基类调用隐藏的虚函数
    bp3->fcn();

    D1 *d1p = &d1obj;
    D2 *d2p = &d2obj;
    // bp2->f2(); // 错误，Base没有f2的成员
    d1p->f2();
    d2p->f2();

    Base *p1 = &d2obj;
    D1 *p2 = &d2obj;
    D2 *p3 = &d2obj;
    // p1->fcn(42);  错误，Base中没有接受一个int的fcn
    p2->fcn(42);
    p3->fcn(42);
    ```

* `通过基类调用隐藏的虚函数`
    1. 见上面代码

* `覆盖重载的函数`
    1. 成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的0个或多个实例
    2. 如果子类要访问父类所有重载函数，在子类的类内用using声明

## 7.构造函数与拷贝控制
> 和其他类一样，位于继承体系中的类也需要控制当期对象执行一系列操作时发生什么样的行为，这些操作包括`创建、拷贝、移动、赋值和销毁。`如果一个类没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成的版本也可以定义成被删除的函数

### 7.1 虚析构函数
* `注意`
    1. 我们在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本
    2. 如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为
    3. 若干一个类需要析构函数，那么它同样需要拷贝和赋值操作。`在虚析构这里不成立，因为一个基类总是需要虚析构函数，显然无法推断该基类是否需要赋值、拷贝`

* `虚析构函数将阻止合成移动操作`
    1. 如果一个类定义了析构函数，即使他通过=default的形式使用了合成的版本，编译器也不会为这个类合成移动操作

### 7.2 合成拷贝控制与继承
* `派生类中删除的拷贝控制与基类的关系`
    1. 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符是被删除的函数或者不可访问，则派生类中的对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作
    2. 析构函数是不可访问或删除，则派生类中合成的默认和拷贝构造将是被删除的
    3. 编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的。原因是派生类对象的积累部分不可移动。同样的，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是删除的

* `移动操作与继承`
    1. 如果派生类需要移动操作，则首先应该在基类中定义

### 7.3 派生类的拷贝控制成员
> 派生类的拷贝和移动构造函数在拷贝和移动自由成员的同时，也要拷贝和移动基类部分的成员

* `定义派生类的拷贝或移动构造函数`
```cpp
class Base {};
class D : public Base {
public:
    // 如果没有提供基类的初始值，基类部分将被默认初始化，而非拷贝
    D(const D& d) : Base(d) {}
    D(D&& d) : Base(std::move(d)) {}
};

D &D::operator={const D &rhs} {
    Base::operator=(rhs);
    // 为派生类赋值
    return *this;
}
```

* `派生类赋值运算符`
    1. 见上代码块

* `派生类析构函数`
    1. 派生类析构只赋值销毁由派生类自己分配的资源
    2. 对象销毁的顺序正好与其创建的顺序相反: 派生类析构函数首先执行，然后是基类的析构函数。即沿着继承体系反方向直至最后

* `在构造函数和析构函数中调用虚函数`
    1. 在基类的构造或析构中中调用派生的虚函数，很可能发生崩溃(构造时，派生类还没构造成，析构时，派生类已经析构了)(`??当我们构建一个对象时，需要把对象的类和构造哈数的类看作是同一个`)
    2. 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数的所属类型相对应的虚函数版本

### 7.4 继承的构造函数
```cpp
class Bulk_quote : public Disc_quote {
public:
    using Disc_quote::Disc_quote;
    // 如果理解嵌套作用域，就理解了这个
    // 编译器会生成构造函数形如
    // derived(params) : base(args) {}
};
```

* `继承的构造函数的特点`
    1. 一个构造函数的using声明不会改变该构造函数的访问级别
    2. 如果一个基类构造函数含有默认实参。这些实参并不会被继承。相反，派生类将获得多个继承的构造函数
    3. 默认、拷贝、移动构造函数不会被继承，这些构造函数按照正常规则被合成
 
## 8.容器与继承
* `在容器中放置(智能)指针而非对象`
    1. 当我们使用容器存放继承体系中的对象时，通常必须才用间接存储的方式。因为不允许在容器中保存不同类型的元素

### 8.1 编写Basket类
```cpp
// 克隆模式？
class Quote {
public:
    // 克隆左值
    virtual Quote* clone() const & { return new Quote(*this); }
    virtual Quote* clone() && { return new Quote(*this); }
    int isbn() {
        // just for complie
        return 42;
    };
};

class Bulk_quote : public Quote {
    Bulk_quote* clone() const & { return new Bulk_quote(*this); }
    Bulk_quote* clone() && { return new Bulk_quote(*this); }
};

class Basket {
public:
    void add_item(const Quote& sale) {
        items.insert(std::make_shared<Quote>(sale.clone()));
    }

    void add_item(const Quote&& sale) {
        items.insert(std::make_shared<Quote>(std::move(sale).clone()));
    }

private:
    static bool compare(const std::shared_ptr<Quote> &lhs, 
            const std::shared_ptr<Quote> &rhs) {
        return lhs->isbn() < rhs->isbn();
    }
    std::multiset<std::shared_ptr<Quote>, decltype(compare)*> items;
};
```

* `定义Basket的成员`
* `隐藏指针`
* `模拟虚拷贝`

## 9.文本查询程序再探(略)
### 9.1 面向对象的解决方案
* `抽象基类`
* `将层次关系隐藏于接口类中`
* `理解这些类的工作机理`

### 9.2 Query_base类和Query类
* `Query类`
* `Query的输出运算符`

### 9.3 派生类
* `WordQuery类`
* `NotQuery类及~运算符`
* `BinaryQuery类`
* `AndQuery类、OrQuery类及相应的运算符`

### 9.4 eval函数
* `OrQuery::eval`
* `AndQuery::eval`
* `NotQuery::eval`

## 小结
## 术语表